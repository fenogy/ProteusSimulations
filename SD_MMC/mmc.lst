CCS PCH C Compiler, Version 3.249, 28193               21-Kas-07 00:11

               Filename: D:\Elektronik\PIC\Proje\MMC\SD_MMC\mmc.lst

               ROM used: 8026 bytes (24%)
                         Largest free fragment is 24742
               RAM used: 275 (18%) at main() level
                         378 (25%) worst case
               Stack:    4 locations

*
0000:  GOTO   1C40
....................  
.................... #include "18f452.h" 
.................... //////// Standard Header file for the PIC18F452 device //////////////// 
.................... #device PIC18F452 
.................... #list 
....................  
.................... #fuses H4,NOWDT,NOPROTECT,NOWRT,NOWRTD,NOLVP,NOOSCSEN,BORV27,PUT,STVREN,NODEBUG,NOWRTB 
.................... #use delay(clock=40000000,RESTART_WDT) 
*
01E0:  MOVLW  01
01E2:  MOVWF  FEA
01E4:  MOVLW  48
01E6:  MOVWF  FE9
01E8:  MOVF   FEF,W
01EA:  BZ    020E
01EC:  MOVLW  0C
01EE:  MOVWF  01
01F0:  MOVLW  BF
01F2:  MOVWF  00
01F4:  CLRWDT
01F6:  DECFSZ 00,F
01F8:  BRA    01F4
01FA:  DECFSZ 01,F
01FC:  BRA    01F0
01FE:  MOVLW  F7
0200:  MOVWF  00
0202:  DECFSZ 00,F
0204:  BRA    0202
0206:  NOP   
0208:  CLRWDT
020A:  DECFSZ FEF,F
020C:  BRA    01EC
020E:  RETLW  00
.................... #use rs232(baud=57600,parity=N,xmit=PIN_C6,rcv=PIN_C7,ERRORS) 
....................  
.................... #include "HDD Driver.c" 
.................... ////////////////////////////////////////////////////////////////////// 
.................... ////////////////////////////////////////////////////////////////////// 
.................... //	Name:			   HDD Driver.c                       					  // 
.................... //	Date:			   02/01/2004		                   					  // 
.................... //	Version:		   1.1											              // 
.................... //	Type:			   PIC C Driver for MMC										  // 
.................... //	Author:        Mike Luck & Douglas Kennedy				           // 
.................... //	Company:		   MPIC3.COM										           // 
.................... ////////////////////////////////////////////////////////////////////// 
.................... ////////////////////////////////////////////////////////////////////// 
....................  
.................... //	Note: 
.................... // 		This code is a work in progress & not a finished fully working 
.................... //			project. Please check www.mpic3.com reguarly for updates. 
....................  
.................... /// PIN Assignments ////////////////////////////// 
.................... #DEFINE _CS PIN_C2 // chip select for MMC 
.................... //#DEFINE SDO PIN_C5 
.................... //#DEFINE CLK PIN_C3 
.................... //#DEFINE SDI PIN_C4 
.................... // SPI hardware pins are 
.................... // SDO C5 
.................... // SDI C4 
.................... // SCK C3 
.................... /////////////////////////////////////////////////////////////// 
....................  
.................... ///// Note old values needed before all SPI modes could be set up using SPI_setup 
.................... /// for 16 parts /////////// 
.................... //#DEFINE SSPCON 0x14 
.................... //#DEFINE SSPSTAT 0x94 
.................... //#BIT SMP=SSPSTAT.7 
.................... //#BIT CKE=SSPSTAT.6 
.................... //#BIT CKP=SSPCON.4 
.................... //#BIT SSPEN=SSPCON.5 
.................... ////////////////////////////// 
....................  
.................... // For 18F452 
.................... #DEFINE SSPSTAT 0x0FC7 
.................... #DEFINE SSPCON1 0x0FC6 
.................... #BIT SMP=SSPSTAT.7 
.................... #BIT CKE=SSPSTAT.6 
.................... #BIT CKP=SSPCON1.4 
....................  
.................... #DEFINE MAX_FILES 2 /// max number of open files 
.................... #DEFINE MMC_BUFF_SIZE 32 /// 32 for PCM 
.................... #DEFINE MMC_FILE_NAME_SIZE 32 
....................  
.................... #DEFINE ROOT_CLUSTER 0 
.................... #DEFINE NEXT_CLUSTER 1 
....................  
.................... #define MMC_INIT_TRACE FALSE 
.................... #define MMC_CMD_TRACE FALSE 
.................... #define MMC_CLUSTER_TRACE FALSE // if true prints to serial port 
.................... #define MMC_OPEN_TRACE FALSE // if true prints to serial port 
.................... #define MMC_READ_TRACE FALSE // if true prints file_addr,cluster index etc 
.................... #define MMC_WRITE_TRACE FALSE 
.................... #define MMC_READ_BLOCK_TRACE FALSE 
.................... #define MMC_SET_BLOCK_LEN_TRACE FALSE 
.................... #define MMC_WRITE_BLOCK_TRACE FALSE 
.................... #define MMC_NEW_CLUSTER FALSE 
.................... ////// MMC prototypes 
.................... #separate 
.................... int init_MMC(int max_tries); 
.................... #separate 
.................... int open_file(int fnbr,char *fname,int16 rec_length); 
.................... #separate 
.................... int file_read(int8 fnbr,char *buff); 
.................... #separate 
.................... int file_write(int8 fnbr,int *buff); 
.................... #separate 
.................... int file_set(int fnbr,int32 offset); 
.................... #separate 
.................... int file_new_cluster(int8 fnbr,int8 mode); /// mode 1=fat1 2=fat2 
....................  
.................... int32 atoint32 (char *s ); 
.................... signed int strncmp(char *s1, char *s2, int n); 
.................... ///////////////////// MMC GLOBALS ///////////////////////////// 
.................... int16 cluster_size_bytes; // bytes in a cluster 
.................... //int16 dir_cluster_chain_ptr; // link to the first cluster in the dir 
....................  
.................... int32 fat1_address; // physical address of fat1 cluster table assigned by INIT_MMC 
.................... int32 fat2_address; // physical address of fat1 cluster table assigned by INIT_MMC 
.................... int32 root_dir_address; // physical address of volume,file,folder tiles assigned by INIT_MMC 
.................... int32 data_area_address; // physical address of data area assigned by INIT_MMC 
.................... int32 winhex_adj; // Win hex hides the bytes in the reserved sectors 
.................... // this means Fat1 is address 512 
.................... // so adj is fat1-512 
....................  
.................... int32 block_size; // current MMC block size 
....................  
.................... int MMC_init=FALSE; 
....................  
.................... int MMC_dir_protected=TRUE; 
....................  
.................... ////////// open file specific globals /////////////////////// 
.................... struct{ 
.................... 	char name[MMC_FILE_NAME_SIZE+1]; // fopen file name 
.................... 	int32 dir_addr_ptr; // physical address of this files tile info 
.................... 	int16 root_cluster_ptr; // location of first cluster in FAT 
.................... 	int16 this_cluster_ptr; // location of current cluster in FAT 
.................... 	int16 next_cluster_ptr; // location of the next cluster for a file or sub dir in FAT 
.................... 	int32 addr_ptr; // physical address in the file the current 
.................... 	// cluster points to 
.................... 	// address=(this_chain_ptr-2)*cluster_size_bytes+data_area_address 
.................... 	// 
.................... 	// cluster_addr(THIS_CLUSTER) assigns it 
.................... 	// cluster_addr(NEXT_CLUSTER) moves to the data the next 
.................... 	// cluster points to 
.................... 	int32 size; // size of open file in bytes 
.................... 	int32 cluster_offset; // offset within the file representing the start of the current cluster 
.................... 	// (0 is start and ends with the cluster contianing eof ) 
.................... 	// auto increased by cluster_size_bytes each time a new cluster is entered 
....................  
.................... 	int32 offset; // current offset into the open file ( 0 is start size(file size) is end) 
.................... 	// auto increased by rec size each time a rec is read 
.................... 	// addr_prt+offset-cluster_offset is physical address of 
.................... 	// the current position within the file 
.................... 	// the physical positions are not always contiguous since the 
.................... 	// clusters of the file are not always adjacent to each other 
.................... 	int16 rec_size; // fopen record_size 
.................... 	// char buff[MMC_BUFF_SIZE+1]; // used for open and for read write 
.................... 	// init MMC uses file 0 buff to fetch the globals 
....................  
.................... } file[MAX_FILES]; 
....................  
....................  
.................... #separate 
.................... int mmc_cmd(int8 cmd,int32 address,int8 tries,int8 valid,int8 invalid){ 
.................... 	int i,r1; 
.................... 	for( i=0;i<16;i++) SPI_READ(0xFF);// digest prior operation 
0210:  MOVLB  1
0212:  CLRF   x77
0214:  MOVF   x77,W
0216:  SUBLW  0F
0218:  BNC   0228
021A:  MOVF   FC9,W
021C:  MOVLW  FF
021E:  MOVWF  FC9
0220:  BTFSS  FC7.0
0222:  BRA    0220
.................... 	// commands 
.................... 	// 7 6 5 4 3 2 1 0 
.................... 	// 0 1 b b b b b b bbbbbb=cmd 
.................... 	// 16=0x50 set blocklength 
.................... 	// 17=0x51 read block 
.................... 	// 24=0x58 write block 
.................... 	#if MMC_CMD_TRACE 
0224:  INCF   x77,F
0226:  BRA    0214
.................... 	printf("\n\r cmd=%2X \n\r",cmd); 
.................... 	#endif 
.................... 	SPI_READ(cmd); 
0228:  MOVF   FC9,W
022A:  MOVFF  16F,FC9
022E:  BTFSS  FC7.0
0230:  BRA    022E
.................... 	SPI_READ(MAKE8(address,3)); 
0232:  MOVFF  173,179
0236:  MOVF   FC9,W
0238:  MOVFF  173,FC9
023C:  BTFSS  FC7.0
023E:  BRA    023C
.................... 	SPI_READ(MAKE8(address,2)); 
0240:  MOVFF  172,179
0244:  MOVF   FC9,W
0246:  MOVFF  172,FC9
024A:  BTFSS  FC7.0
024C:  BRA    024A
.................... 	SPI_READ(MAKE8(address,1)); 
024E:  MOVFF  171,179
0252:  MOVF   FC9,W
0254:  MOVFF  171,FC9
0258:  BTFSS  FC7.0
025A:  BRA    0258
.................... 	SPI_READ(MAKE8(address,0)); 
025C:  MOVFF  170,179
0260:  MOVF   FC9,W
0262:  MOVFF  170,FC9
0266:  BTFSS  FC7.0
0268:  BRA    0266
.................... 	SPI_READ(0x95); // valid crc for 0x40 only invalid for others but spi mode doesn't care 
026A:  MOVF   FC9,W
026C:  MOVLW  95
026E:  MOVWF  FC9
0270:  BTFSS  FC7.0
0272:  BRA    0270
.................... 	for(i=0;i< tries;i++) { 
0274:  CLRF   x77
0276:  MOVF   x74,W
0278:  SUBWF  x77,W
027A:  BC    029E
.................... 		r1=SPI_READ(0xFF); 
027C:  MOVF   FC9,W
027E:  MOVLW  FF
0280:  MOVWF  FC9
0282:  BTFSS  FC7.0
0284:  BRA    0282
0286:  MOVFF  FC9,178
.................... 		#if MMC_CMD_TRACE 
.................... 			printf(" %2X",r1); 
.................... 		#endif 
.................... 		if (r1==valid) break; 
028A:  MOVF   x75,W
028C:  SUBWF  x78,W
028E:  BNZ   0292
0290:  BRA    029E
.................... 		if (r1==invalid) break; 
0292:  MOVF   x76,W
0294:  SUBWF  x78,W
0296:  BNZ   029A
0298:  BRA    029E
.................... 	} 
029A:  INCF   x77,F
029C:  BRA    0276
.................... 	return(r1); 
029E:  MOVFF  178,01
.................... } 
02A2:  MOVLB  0
02A4:  RETLW  00
....................  
....................  
.................... #separate 
.................... int set_BLOCKLEN( int32 size){ 
.................... 	int r1; 
....................  
.................... 	r1=mmc_cmd(0x50,size,16,0x00,0x40); /// cmd.data,tries,valid code,invlaid code 
02A6:  MOVLW  50
02A8:  MOVLB  1
02AA:  MOVWF  x6F
02AC:  MOVFF  163,173
02B0:  MOVFF  162,172
02B4:  MOVFF  161,171
02B8:  MOVFF  160,170
02BC:  MOVLW  10
02BE:  MOVWF  x74
02C0:  CLRF   x75
02C2:  MOVLW  40
02C4:  MOVWF  x76
02C6:  MOVLB  0
02C8:  RCALL  0210
02CA:  MOVFF  01,164
.................... 	if (r1==0x00) goto done ; 
02CE:  MOVLB  1
02D0:  MOVF   x64,F
02D2:  BNZ   02D6
02D4:  BRA    02E4
.................... 	if (r1==0x40) goto invalid; 
02D6:  MOVF   x64,W
02D8:  SUBLW  40
02DA:  BNZ   02DE
02DC:  BRA    02E4
....................  
....................  
.................... 	return(false); 
02DE:  MOVLW  00
02E0:  MOVWF  01
02E2:  BRA    02F8
.................... 	invalid: 
.................... 	#IF MMC_SET_BLOCK_LEN_TRACE 
.................... 		printf("\n\r para err\n\r"); 
.................... 	#ENDIF 
.................... done: 
.................... 	block_size=size; //// assign global block size 
02E4:  MOVFF  163,1F
02E8:  MOVFF  162,1E
02EC:  MOVFF  161,1D
02F0:  MOVFF  160,1C
.................... 	//printf("\n\r blk size=%lu",block_size); 
.................... 	return(true); 
02F4:  MOVLW  01
02F6:  MOVWF  01
.................... } 
02F8:  MOVLB  0
02FA:  RETLW  00
....................  
....................  
.................... #separate 
.................... int read_BLOCK( int32 address, char *buff){ 
.................... 	//// low level read ..requires block len to be called first to set global blocksize 
.................... 	int r1; 
.................... 	long i,iw; /// allows large gt 255 buff size addressing 
.................... 	//int data[128]; 
.................... 	r1=mmc_cmd(0x51,address,16,0x00,0x40); 
02FC:  MOVLW  51
02FE:  MOVLB  1
0300:  MOVWF  x6F
0302:  MOVFF  167,173
0306:  MOVFF  166,172
030A:  MOVFF  165,171
030E:  MOVFF  164,170
0312:  MOVLW  10
0314:  MOVWF  x74
0316:  CLRF   x75
0318:  MOVLW  40
031A:  MOVWF  x76
031C:  MOVLB  0
031E:  RCALL  0210
0320:  MOVFF  01,16A
....................  
.................... 	if (r1==0x00) goto get_token ; // we can read data payload 
0324:  MOVLB  1
0326:  MOVF   x6A,F
0328:  BNZ   032C
032A:  BRA    0340
.................... 	if (r1==0x40) goto invalid; 
032C:  MOVF   x6A,W
032E:  SUBLW  40
0330:  BNZ   0334
0332:  BRA    033A
....................  
.................... 	#IF MMC_READ_BLOCK_TRACE 
.................... 		printf("\n\r read block err 1 address=%lu \n\r",address); 
.................... 	#ENDIF 
.................... 	return(false); 
0334:  MOVLW  00
0336:  MOVWF  01
0338:  BRA    03C2
.................... 	invalid: 
.................... 	#IF MMC_READ_BLOCK_TRACE 
.................... 		printf("\n\r read block err 2 adress=%lu \n\r",address); 
.................... 	#ENDIF 
.................... 	return(false); 
033A:  MOVLW  00
033C:  MOVWF  01
033E:  BRA    03C2
.................... 	get_token: 
.................... 	for(iw=0;iw<1024;iw++){ 
0340:  CLRF   x6E
0342:  CLRF   x6D
0344:  MOVF   x6E,W
0346:  SUBLW  03
0348:  BNC   0368
.................... 	r1=SPI_READ(0xFF); 
034A:  MOVF   FC9,W
034C:  MOVLW  FF
034E:  MOVWF  FC9
0350:  BTFSS  FC7.0
0352:  BRA    0350
0354:  MOVFF  FC9,16A
.................... 	//data[iw]=r1; 
.................... 	if (r1==0xFE) goto read_data; // read token $FE 
0358:  MOVF   x6A,W
035A:  SUBLW  FE
035C:  BNZ   0360
035E:  BRA    036E
.................... 	} 
.................... 	#IF MMC_READ_BLOCK_TRACE 
0360:  INCF   x6D,F
0362:  BTFSC  FD8.2
0364:  INCF   x6E,F
0366:  BRA    0344
.................... 		printf("\n\r read block err 3 address=%lu \n\r",address); 
.................... 	#ENDIF 
.................... 	return(false); 
0368:  MOVLW  00
036A:  MOVWF  01
036C:  BRA    03C2
.................... 	read_data: 
.................... 	#IF MMC_READ_BLOCK_TRACE 
.................... 		printf("\n\r read block tries for FE =%lu \n\r",iw); 
.................... 	#ENDIF 
....................  
.................... 	for (i=0;i<block_size;i++) buff[i]=SPI_READ(0xFF); 
036E:  CLRF   x6C
0370:  CLRF   x6B
0372:  MOVF   1F,F
0374:  BNZ   0388
0376:  MOVF   1E,F
0378:  BNZ   0388
037A:  MOVF   x6C,W
037C:  SUBWF  1D,W
037E:  BNC   03AA
0380:  BNZ   0388
0382:  MOVF   1C,W
0384:  SUBWF  x6B,W
0386:  BC    03AA
0388:  MOVF   x68,W
038A:  ADDWF  x6B,W
038C:  MOVWF  FE9
038E:  MOVF   x69,W
0390:  ADDWFC x6C,W
0392:  MOVWF  FEA
0394:  MOVF   FC9,W
0396:  MOVLW  FF
0398:  MOVWF  FC9
039A:  BTFSS  FC7.0
039C:  BRA    039A
039E:  MOVFF  FC9,FEF
03A2:  INCF   x6B,F
03A4:  BTFSC  FD8.2
03A6:  INCF   x6C,F
03A8:  BRA    0372
.................... 	SPI_READ(0xFF); // read crc 
03AA:  MOVF   FC9,W
03AC:  MOVLW  FF
03AE:  MOVWF  FC9
03B0:  BTFSS  FC7.0
03B2:  BRA    03B0
.................... 	SPI_READ(0xFF); 
03B4:  MOVF   FC9,W
03B6:  MOVLW  FF
03B8:  MOVWF  FC9
03BA:  BTFSS  FC7.0
03BC:  BRA    03BA
....................  
.................... 	return(true); 
03BE:  MOVLW  01
03C0:  MOVWF  01
.................... } 
03C2:  MOVLB  0
03C4:  RETLW  00
....................  
.................... ////////////////////////////////////////////////////////////////// 
.................... ///////////////////////////////// INIT MMC /////////////////////// 
.................... ////////////////////////////////////////////////////////////////// 
.................... #separate 
....................  
.................... int init_MMC(int max_tries){ 
.................... 	int32 start_lsec; 
.................... 	int16 sec_resv,sec_for_FAT,bytes_per_sector,root_dir_entries, 
.................... 	sec_for_data,count_of_clusters,root_dir_sectors,total_sectors; 
.................... 	int i,tries,sec_per_cluster,c; 
.................... 	char buff[32]; 
.................... 	tries=0; 
*
048C:  MOVLB  1
048E:  CLRF   x25
.................... 	cmd0: 
.................... 	///////////////////// place null treminators in globals fname and buff 
.................... 	for(i=0;i<MAX_FILES;i++){ 
0490:  CLRF   x24
0492:  MOVF   x24,W
0494:  SUBLW  01
0496:  BNC   04DE
.................... 		file[i].name[0]=0; 
0498:  MOVF   x24,W
049A:  MULLW  3D
049C:  MOVF   FF3,W
049E:  CLRF   x49
04A0:  MOVWF  x48
04A2:  MOVLW  22
04A4:  ADDWF  x48,W
04A6:  MOVWF  FE9
04A8:  MOVLW  00
04AA:  ADDWFC x49,W
04AC:  MOVWF  FEA
04AE:  CLRF   FEF
.................... 		file[i].rec_size=32; //// default rec_size = 32 byte tile size of FAT16 
04B0:  MOVF   x24,W
04B2:  MULLW  3D
04B4:  MOVF   FF3,W
04B6:  CLRF   x49
04B8:  MOVWF  x48
04BA:  MOVLW  3B
04BC:  ADDWF  x48,W
04BE:  MOVWF  01
04C0:  MOVLW  00
04C2:  ADDWFC x49,W
04C4:  MOVWF  03
04C6:  MOVF   01,W
04C8:  ADDLW  22
04CA:  MOVWF  FE9
04CC:  MOVLW  00
04CE:  ADDWFC 03,W
04D0:  MOVWF  FEA
04D2:  CLRF   FEC
04D4:  MOVF   FED,F
04D6:  MOVLW  20
04D8:  MOVWF  FEF
.................... 	} 
04DA:  INCF   x24,F
04DC:  BRA    0492
.................... 	//buff[MMC_BUFF_SIZE]=0; 
.................... 	//frec_size=32; //// default rec_size = 32 byte tile size of FAT16 
.................... 	output_high(_CS); /// reset chip hardware !!! required 
04DE:  BCF    F94.2
04E0:  BSF    F8B.2
.................... 	delay_ms(20); 
04E2:  MOVLW  14
04E4:  MOVWF  x48
04E6:  MOVLB  0
04E8:  RCALL  01E0
.................... 	for(i=0;i<20;i++) SPI_READ(0xFF); // min 80 clocks to get MMC ready 
04EA:  MOVLB  1
04EC:  CLRF   x24
04EE:  MOVF   x24,W
04F0:  SUBLW  13
04F2:  BNC   0502
04F4:  MOVF   FC9,W
04F6:  MOVLW  FF
04F8:  MOVWF  FC9
04FA:  BTFSS  FC7.0
04FC:  BRA    04FA
04FE:  INCF   x24,F
0500:  BRA    04EE
.................... 	output_low(_CS); /// !!! required 
0502:  BCF    F94.2
0504:  BCF    F8B.2
.................... 	delay_ms(20); 
0506:  MOVLW  14
0508:  MOVWF  x48
050A:  MOVLB  0
050C:  RCALL  01E0
.................... 	#if MMC_INIT_TRACE 
.................... 		printf("cmd0"); 
.................... 	#ENDIF 
.................... 	c=mmc_cmd(0x40,0x00000000,128,0x01,0x99); 
050E:  MOVLW  40
0510:  MOVLB  1
0512:  MOVWF  x6F
0514:  CLRF   x73
0516:  CLRF   x72
0518:  CLRF   x71
051A:  CLRF   x70
051C:  MOVLW  80
051E:  MOVWF  x74
0520:  MOVLW  01
0522:  MOVWF  x75
0524:  MOVLW  99
0526:  MOVWF  x76
0528:  MOVLB  0
052A:  RCALL  0210
052C:  MOVFF  01,127
....................  
.................... 	if (c==0x01) goto exit_cmd1; 
0530:  MOVLB  1
0532:  DECFSZ x27,W
0534:  BRA    0538
0536:  BRA    054C
....................  
.................... 	// note: i must cycle at least 8 times (16 is safe ) 
....................  
.................... 	if (tries++<max_tries) goto cmd0; /// restart 
0538:  MOVF   x25,W
053A:  INCF   x25,F
053C:  SUBWF  x0F,W
053E:  BZ    0546
0540:  BNC   0546
0542:  BRA    0490
.................... 	else return (10); 
0544:  BRA    054C
0546:  MOVLW  0A
0548:  MOVWF  01
054A:  BRA    0872
.................... 	exit_cmd1: 
.................... 	// CPDMOD - This SOMETIMES seems to be necessary 
.................... 	// output_high(_CS); 
.................... 	// SPI_READ(0xFF); // min 8 clocks to get MMC ready 
.................... 	// output_low(_CS); 
.................... 	//CPDMOD End 
....................  
....................  
.................... 	tries=0; 
054C:  CLRF   x25
.................... 	cmd1: 
....................  
.................... 	/// now try to switch to idle mode 
.................... 	/// Note: cmd1(idle) is the only command allowed after a cmd0(reset) 
.................... 	// 
....................  
.................... 	c=mmc_cmd(0x41,0x00000000,128,0x00,0x99); 
054E:  MOVLW  41
0550:  MOVWF  x6F
0552:  CLRF   x73
0554:  CLRF   x72
0556:  CLRF   x71
0558:  CLRF   x70
055A:  MOVLW  80
055C:  MOVWF  x74
055E:  CLRF   x75
0560:  MOVLW  99
0562:  MOVWF  x76
0564:  MOVLB  0
0566:  RCALL  0210
0568:  MOVFF  01,127
.................... 	if (c==0x00) { goto ready;} 
056C:  MOVLB  1
056E:  MOVF   x27,F
0570:  BNZ   0574
0572:  BRA    05A2
....................  
....................  
.................... 	if( tries++<max_tries) { printf("cmd1"); goto cmd1;} 
0574:  MOVF   x25,W
0576:  INCF   x25,F
0578:  SUBWF  x0F,W
057A:  BZ    059C
057C:  BNC   059C
057E:  CLRF   x48
0580:  MOVF   x48,W
0582:  MOVLB  0
0584:  RCALL  0004
0586:  IORLW  00
0588:  BZ    0596
058A:  MOVLB  1
058C:  INCF   x48,F
058E:  BTFSS  F9E.4
0590:  BRA    058E
0592:  MOVWF  FAD
0594:  BRA    0580
0596:  MOVLB  1
0598:  BRA    054E
.................... 	else return(11); 
059A:  BRA    05A2
059C:  MOVLW  0B
059E:  MOVWF  01
05A0:  BRA    0872
.................... 	ready: 
.................... 	//for( i=0;i<32;i++) SPI_READ(0xFF);// digest operation 
.................... 	/// MMC is inialized and in idle state ready for commands 
.................... 	//// 
.................... 	//// we need to first access the master boot sector physical address=0 
.................... 	/// 
.................... 	if(set_BLOCKLEN((int32)32)==false) return(12); /// sets global block_size to 32 
05A2:  CLRF   x63
05A4:  CLRF   x62
05A6:  CLRF   x61
05A8:  MOVLW  20
05AA:  MOVWF  x60
05AC:  MOVLB  0
05AE:  RCALL  02A6
05B0:  MOVF   01,F
05B2:  BNZ   05BC
05B4:  MOVLW  0C
05B6:  MOVWF  01
05B8:  MOVLB  1
05BA:  BRA    0872
....................  
.................... 	if (read_block(0x00000000,buff)==false) return (99); /// read the first few bytes 
05BC:  MOVLB  1
05BE:  CLRF   x67
05C0:  CLRF   x66
05C2:  CLRF   x65
05C4:  CLRF   x64
05C6:  MOVLW  01
05C8:  MOVWF  x69
05CA:  MOVLW  28
05CC:  MOVWF  x68
05CE:  MOVLB  0
05D0:  RCALL  02FC
05D2:  MOVF   01,F
05D4:  BNZ   05DE
05D6:  MOVLW  63
05D8:  MOVWF  01
05DA:  MOVLB  1
05DC:  BRA    0872
.................... 	#if MMC_INIT_TRACE 
.................... 		printf("\n\r sector0="); 
.................... 		for(i=0;i<32;i++)printf("%2X ",buff[i]); 
.................... 	#ENDIF 
.................... 	if (buff[0]==0xEB || buff[0]==0xE9){ 
05DE:  MOVLB  1
05E0:  MOVF   x28,W
05E2:  SUBLW  EB
05E4:  BZ    05EC
05E6:  MOVF   x28,W
05E8:  SUBLW  E9
05EA:  BNZ   05EE
.................... 		/// sector 0 is the boot sector 
.................... 		#if MMC_INIT_TRACE 
.................... 			printf("\n\r boot sector= 0"); 
.................... 		#ENDIF 
.................... 	} 
.................... 	else{ 
05EC:  BRA    065C
.................... 		//// partition 
....................  
.................... 		/// access the master boot sector physical address 0 at offset 1BE 
.................... 		if (read_BLOCK(0x000001BE,buff)==false) return(13); 
05EE:  CLRF   x67
05F0:  CLRF   x66
05F2:  MOVLW  01
05F4:  MOVWF  x65
05F6:  MOVLW  BE
05F8:  MOVWF  x64
05FA:  MOVLW  01
05FC:  MOVWF  x69
05FE:  MOVLW  28
0600:  MOVWF  x68
0602:  MOVLB  0
0604:  RCALL  02FC
0606:  MOVF   01,F
0608:  BNZ   0614
060A:  MOVLW  0D
060C:  MOVWF  01
060E:  MOVLB  1
0610:  BRA    0872
0612:  MOVLB  0
.................... 		#if MMC_INIT_TRACE 
.................... 			for(i=0;i<32;i++)printf("%2X ",buff[i]); 
.................... 		#ENDIF 
.................... 		// start_lsec is address of the partion boot sector 
.................... 		start_lsec=make32(buff[11],buff[10],buff[9],buff[8]); 
0614:  MOVFF  133,113
0618:  MOVFF  132,112
061C:  MOVFF  131,111
0620:  MOVFF  130,110
.................... 		#if MMC_INIT_TRACE 
.................... 			printf("\n\r boot sector= %lu",start_lsec); 
.................... 		#ENDIF 
.................... 		if (read_BLOCK(start_lsec*512,buff)==false) return(14); 
0624:  BCF    FD8.0
0626:  MOVLB  1
0628:  CLRF   x48
062A:  RLCF   x10,W
062C:  MOVWF  x49
062E:  RLCF   x11,W
0630:  MOVWF  x4A
0632:  RLCF   x12,W
0634:  MOVWF  x4B
0636:  MOVWF  x67
0638:  MOVFF  14A,166
063C:  MOVFF  149,165
0640:  MOVFF  148,164
0644:  MOVLW  01
0646:  MOVWF  x69
0648:  MOVLW  28
064A:  MOVWF  x68
064C:  MOVLB  0
064E:  RCALL  02FC
0650:  MOVF   01,F
0652:  BNZ   065E
0654:  MOVLW  0E
0656:  MOVWF  01
0658:  MOVLB  1
065A:  BRA    0872
065C:  MOVLB  0
.................... 	} 
....................  
.................... 	bytes_per_sector=make16(buff[12],buff[11]); 
065E:  MOVFF  134,119
0662:  MOVFF  133,118
.................... 	if(bytes_per_sector!=512) return(15); 
0666:  MOVLB  1
0668:  MOVF   x18,F
066A:  BNZ   0672
066C:  MOVF   x19,W
066E:  SUBLW  02
0670:  BZ    0678
0672:  MOVLW  0F
0674:  MOVWF  01
0676:  BRA    0872
.................... 	sec_per_cluster=buff[13]; 
0678:  MOVFF  135,126
.................... 	cluster_size_bytes=(int16)sec_per_cluster*bytes_per_sector; 
067C:  CLRF   x49
067E:  MOVFF  126,148
0682:  MOVFF  149,14B
0686:  MOVFF  126,14A
068A:  MOVFF  119,14D
068E:  MOVFF  118,14C
0692:  MOVLB  0
0694:  RCALL  03C6
0696:  MOVFF  02,07
069A:  MOVFF  01,06
....................  
....................  
.................... 	sec_resv=make16(buff[15],buff[14]); 
069E:  MOVFF  137,115
06A2:  MOVFF  136,114
....................  
.................... 	root_dir_entries=make16(buff[18],buff[17]);// number of 32 byte tiles 
06A6:  MOVFF  13A,11B
06AA:  MOVFF  139,11A
....................  
.................... 	total_sectors=make16(buff[20],buff[19]); 
06AE:  MOVFF  13C,123
06B2:  MOVFF  13B,122
....................  
.................... 	sec_for_FAT=make16(buff[23],buff[22]); 
06B6:  MOVFF  13F,117
06BA:  MOVFF  13E,116
.................... 	//branch to file directory 
.................... 	fat1_address=(start_lsec+sec_resv)*bytes_per_sector; 
06BE:  MOVLB  1
06C0:  MOVF   x14,W
06C2:  ADDWF  x10,W
06C4:  MOVWF  x48
06C6:  MOVF   x15,W
06C8:  ADDWFC x11,W
06CA:  MOVWF  x49
06CC:  MOVLW  00
06CE:  ADDWFC x12,W
06D0:  MOVWF  x4A
06D2:  MOVLW  00
06D4:  ADDWFC x13,W
06D6:  MOVWF  x4B
06D8:  MOVWF  x6F
06DA:  MOVFF  14A,16E
06DE:  MOVFF  149,16D
06E2:  MOVFF  148,16C
06E6:  CLRF   x73
06E8:  CLRF   x72
06EA:  MOVFF  119,171
06EE:  MOVFF  118,170
06F2:  MOVLB  0
06F4:  RCALL  03E8
06F6:  MOVFF  03,0B
06FA:  MOVFF  02,0A
06FE:  MOVFF  01,09
0702:  MOVFF  00,08
.................... 	fat2_address=fat1_address+bytes_per_sector*sec_for_FAT; 
0706:  MOVFF  119,14B
070A:  MOVFF  118,14A
070E:  MOVFF  117,14D
0712:  MOVFF  116,14C
0716:  RCALL  03C6
0718:  MOVF   01,W
071A:  ADDWF  08,W
071C:  MOVWF  0C
071E:  MOVF   02,W
0720:  ADDWFC 09,W
0722:  MOVWF  0D
0724:  MOVLW  00
0726:  ADDWFC 0A,W
0728:  MOVWF  0E
072A:  MOVLW  00
072C:  ADDWFC 0B,W
072E:  MOVWF  0F
.................... 	root_dir_address=(sec_for_FAT*2+start_lsec+sec_resv)*bytes_per_sector; 
0730:  BCF    FD8.0
0732:  MOVLB  1
0734:  RLCF   x16,W
0736:  MOVWF  x48
0738:  RLCF   x17,W
073A:  MOVWF  x49
073C:  MOVF   x48,W
073E:  ADDWF  x10,W
0740:  MOVWF  x4A
0742:  MOVF   x49,W
0744:  ADDWFC x11,W
0746:  MOVWF  x4B
0748:  MOVLW  00
074A:  ADDWFC x12,W
074C:  MOVWF  x4C
074E:  MOVLW  00
0750:  ADDWFC x13,W
0752:  MOVWF  x4D
0754:  MOVF   x14,W
0756:  ADDWF  x4A,W
0758:  MOVWF  x4E
075A:  MOVF   x15,W
075C:  ADDWFC x4B,W
075E:  MOVWF  x4F
0760:  MOVLW  00
0762:  ADDWFC x4C,W
0764:  MOVWF  x50
0766:  MOVLW  00
0768:  ADDWFC x4D,W
076A:  MOVWF  x51
076C:  MOVWF  x6F
076E:  MOVFF  150,16E
0772:  MOVFF  14F,16D
0776:  MOVFF  14E,16C
077A:  CLRF   x73
077C:  CLRF   x72
077E:  MOVFF  119,171
0782:  MOVFF  118,170
0786:  MOVLB  0
0788:  RCALL  03E8
078A:  MOVFF  03,13
078E:  MOVFF  02,12
0792:  MOVFF  01,11
0796:  MOVFF  00,10
.................... 	data_area_address=root_dir_address+root_dir_entries*32; 
079A:  MOVLB  1
079C:  RLCF   x1A,W
079E:  MOVWF  02
07A0:  RLCF   x1B,W
07A2:  MOVWF  03
07A4:  RLCF   02,F
07A6:  RLCF   03,F
07A8:  RLCF   02,F
07AA:  RLCF   03,F
07AC:  RLCF   02,F
07AE:  RLCF   03,F
07B0:  RLCF   02,F
07B2:  RLCF   03,F
07B4:  MOVLW  E0
07B6:  ANDWF  02,F
07B8:  MOVF   02,W
07BA:  ADDWF  10,W
07BC:  MOVWF  14
07BE:  MOVF   03,W
07C0:  ADDWFC 11,W
07C2:  MOVWF  15
07C4:  MOVLW  00
07C6:  ADDWFC 12,W
07C8:  MOVWF  16
07CA:  MOVLW  00
07CC:  ADDWFC 13,W
07CE:  MOVWF  17
.................... 	///// check for FAT16 
.................... 	root_dir_sectors=root_dir_entries>>4; 
07D0:  RRCF   x1B,W
07D2:  MOVWF  x21
07D4:  RRCF   x1A,W
07D6:  MOVWF  x20
07D8:  RRCF   x21,F
07DA:  RRCF   x20,F
07DC:  RRCF   x21,F
07DE:  RRCF   x20,F
07E0:  RRCF   x21,F
07E2:  RRCF   x20,F
07E4:  MOVLW  0F
07E6:  ANDWF  x21,F
....................  
.................... 	sec_for_data=total_sectors - sec_resv -sec_for_fat*2 -root_dir_sectors; 
07E8:  MOVF   x14,W
07EA:  SUBWF  x22,W
07EC:  MOVWF  x48
07EE:  MOVF   x15,W
07F0:  SUBWFB x23,W
07F2:  MOVWF  x49
07F4:  BCF    FD8.0
07F6:  RLCF   x16,W
07F8:  MOVWF  02
07FA:  RLCF   x17,W
07FC:  MOVWF  03
07FE:  MOVF   02,W
0800:  SUBWF  x48,W
0802:  MOVWF  x4A
0804:  MOVF   03,W
0806:  SUBWFB x49,W
0808:  MOVWF  x4B
080A:  MOVF   x20,W
080C:  SUBWF  x4A,W
080E:  MOVWF  x1C
0810:  MOVF   x21,W
0812:  SUBWFB x4B,W
0814:  MOVWF  x1D
....................  
.................... 	count_of_clusters=sec_for_data/sec_per_cluster; 
0816:  MOVFF  11D,149
081A:  MOVFF  11C,148
081E:  CLRF   x4B
0820:  MOVFF  126,14A
0824:  MOVLB  0
0826:  BRA    0442
0828:  MOVFF  02,11F
082C:  MOVFF  01,11E
....................  
.................... 	if (count_of_clusters <4085 || count_of_clusters>65525) return(17); 
0830:  MOVLB  1
0832:  MOVF   x1F,W
0834:  SUBLW  0F
0836:  BNC   0840
0838:  BNZ   0850
083A:  MOVF   x1E,W
083C:  SUBLW  F4
083E:  BC    0850
0840:  MOVF   x1F,W
0842:  SUBLW  FE
0844:  BC    0856
0846:  XORLW  FF
0848:  BNZ   0850
084A:  MOVF   x1E,W
084C:  SUBLW  F5
084E:  BC    0856
0850:  MOVLW  11
0852:  MOVWF  01
0854:  BRA    0872
....................  
.................... 	winhex_adj=fat1_address-bytes_per_sector; 
0856:  MOVF   x18,W
0858:  SUBWF  08,W
085A:  MOVWF  18
085C:  MOVF   x19,W
085E:  SUBWFB 09,W
0860:  MOVWF  19
0862:  MOVLW  00
0864:  SUBWFB 0A,W
0866:  MOVWF  1A
0868:  MOVLW  00
086A:  SUBWFB 0B,W
086C:  MOVWF  1B
....................  
.................... 	#if MMC_INIT_TRACE 
....................  
.................... 		printf("Files:/n/r"); 
.................... 		for(i=0;i<MAX_FILES;i++){ 
.................... 			printf("/n/r",file[i].name[i]); 
.................... 		} 
....................  
.................... 	#ENDIF 
....................  
.................... 	return(0); 
086E:  MOVLW  00
0870:  MOVWF  01
.................... } 
0872:  MOVLB  0
0874:  GOTO   1D40 (RETURN)
....................  
....................  
.................... #separate 
.................... int get_CID(char s){ 
.................... 	int i,r1; 
.................... 	r1=mmc_cmd(0x4A,0x00000000,16,0x00,0x99); 
....................  
....................  
.................... 	if (r1==0x00) goto get_token ; // we can read data payload 
....................  
.................... 	return(false); 
.................... 	get_token: 
.................... 	for(i=0;i<16;i++)if (SPI_READ(0xFF)==0xFE) goto read_CID; // read token $FE 
.................... 	return(false); 
.................... 	read_CID: 
.................... 	//for (i=0;i<18;i++) s[i]=SPI_READ(0xFF); 
....................  
.................... 	return(true); 
.................... } 
....................  
....................  
.................... #separate 
.................... int get_CSD(char s){ 
.................... 	int i,r1; 
.................... 	r1=mmc_cmd(0x4A,0x00000000,16,0x00,0x99); 
....................  
....................  
.................... 	if (r1==0x00) goto get_token ; // we can read data payload 
....................  
.................... 	return(false); 
.................... 	get_token: 
.................... 	for(i=0;i<16;i++)if (SPI_READ(0xFF)==0xFE) goto read_CSD; // read token $FE 
.................... 	return(false); 
.................... 	read_CSD: 
.................... 	//for(i=0;i<18;i++) s[i]=SPI_READ(0xFF); 
....................  
.................... 	return(true); 
.................... } 
....................  
....................  
.................... #separate 
.................... int write_BLOCK( int32 address,char *buff,int16 size) 
.................... { 
.................... 	/// low level write ....MMC restriction is that exactly 512 bytes must be written 
.................... 	/// so a 512 byte section is read in starting at address the first (size) bytes 
.................... 	/// are over written with the new data and the updated 512 bytes written back 
.................... 	/// the starting address of the block that contains the requeseted address 
.................... 	/// 
.................... 	/// the data may span a block if so it is split and two writes are done 
.................... 	/// so as to maitain MMC 512 write boundary restrictions 
....................  
.................... 	int r1,a,b,c,d; 
.................... 	int16 i,blk_offset,bytes_posted; 
.................... 	char tmp_buff[512]; 
.................... 	int32 block_address; 
....................  
.................... 	#if MMC_WRITE_BLOCK_TRACE 
.................... 		printf("addr=%lu",address); 
.................... 	#endif 
....................  
.................... 	a=make8(address,3); 
.................... 	b=make8(address,2); 
.................... 	c=make8(address,1); 
.................... 	c=c & 0b11111110; 
.................... 	d=0; 
.................... 	block_address=make32(a,b,c,d); //// address int divided by 512 
.................... 	#if MMC_WRITE_BLOCK_TRACE 
.................... 		printf("wb>> size=%lu payload=",size); 
.................... 		for(i=0;i<size;i++)printf("%c",buff[i]); 
.................... 	#endif 
....................  
.................... 	/// first set up the block size to 512 
.................... 	if(set_BLOCKLEN((int32)512)==false) return(false); // sets global block_size 
....................  
.................... 	if(block_size!=512) return(false); 
.................... 	bytes_posted=0; /// no data updated yet 
....................  
.................... 	//////////////////////////////////////////////// 
.................... 	next_block: /// loop back here for second block 
.................... 	//////////////////////////////////////////////// 
.................... 	#if MMC_WRITE_BLOCK_TRACE 
.................... 		printf("\n\r blk addr=%lu \n\r",block_address); 
.................... 	#endif 
....................  
.................... 	if((block_address < data_area_address) && MMC_dir_protected) return(false); 
....................  
.................... 	MMC_dir_protected=true; 
.................... 	#if MMC_WRITE_BLOCK_TRACE 
.................... 		printf("read blk"); 
.................... 	#endif 
.................... 	/// first read in the existing block 
.................... 	if(read_block(block_address,tmp_buff)==false) return(false) ; 
....................  
....................  
....................  
.................... 	/// now update the block with new data 
.................... 	blk_offset=(address - block_address); /// offset within the block 
.................... 	#if MMC_WRITE_BLOCK_TRACE 
.................... 		printf("blk_offset=%lu size=%lu",blk_offset,size); 
.................... 	#endif 
....................  
.................... 	if( blk_offset + size > 512 ){ 
.................... 		// data spans the block so write to end of block first 
....................  
.................... 		#if MMC_WRITE_BLOCK_TRACE 
.................... 			//// original data 
.................... 			printf("\n\r spans wb="); 
.................... 			for(i=blk_offset;i<512;i++)printf("%c",tmp_buff[i]); 
.................... 		#endif 
....................  
.................... 		for (i=blk_offset;i < 512;i++)tmp_buff[i]=buff[i-blk_offset]; 
....................  
.................... 		#if MMC_WRITE_BLOCK_TRACE 
.................... 			/// updated data 
.................... 			printf("\n\r spans wb*="); 
.................... 			for(i=blk_offset;i<512;i++)printf("%c",tmp_buff[i]); 
.................... 		#endif 
....................  
.................... 		bytes_posted=512-blk_offset; /// wrote from offset to end of block 
....................  
.................... 		#if MMC_WRITE_BLOCK_TRACE 
.................... 			printf("\n\r posted=%lu",bytes_posted); 
.................... 		#endif 
....................  
.................... 	} 
.................... 	else{ 
.................... 		//original or remaining spanned block data fits in next block or original block 
....................  
.................... 		#if MMC_WRITE_BLOCK_TRACE 
.................... 			printf(" blk offset=%lu",blk_offset); 
.................... 			/// original data 
.................... 			printf("\n\r wb="); 
.................... 			for(i=blk_offset;i<blk_offset+size;i++)printf("%c",tmp_buff[i]); 
.................... 		#endif 
....................  
.................... 		for (i=blk_offset;i<blk_offset+ size;i++)tmp_buff[i]=buff[bytes_posted+i-blk_offset]; 
....................  
.................... 		#if MMC_WRITE_BLOCK_TRACE 
.................... 			/// updated data 
.................... 			printf("\n\r wb*="); 
.................... 			for(i=blk_offset;i<blk_offset+size;i++)printf("%c",tmp_buff[i]); 
.................... 		#endif 
....................  
.................... 		bytes_posted=size; 
....................  
.................... 		#if MMC_WRITE_BLOCK_TRACE 
.................... 			printf("\n\r posted=%lu",bytes_posted); 
.................... 		#endif 
....................  
.................... 	} 
....................  
.................... 	/////////////////////////////////// 
.................... 	/////////// write out the block 
.................... 	////////////////////////////////// 
.................... 	#if MMC_WRITE_BLOCK_TRACE 
.................... 		printf("wb>> writing block %lu",block_address); 
.................... 	#endif 
.................... 	r1=mmc_cmd(0x58,block_address,16,0x00,0x40); 
....................  
....................  
.................... 	if (r1==0x00) goto send_token ; // we can send data payload 
.................... 	if (r1==0x40) goto invalid; 
....................  
....................  
.................... 	return(false); 
.................... invalid: 
.................... 	printf("\n\r write block err %2X\n\r",r1); 
.................... 	return(false); 
.................... 	send_token: 
.................... 	SPI_READ(0xFE); 
....................  
.................... 	for (i=0;i < 512;i++) { 
....................  
.................... 		SPI_READ(tmp_buff[i]); /// send payload 
.................... 	} 
....................  
....................  
.................... 	SPI_READ(0xFF); // send dummy chcksum 
.................... 	SPI_READ(0xFF); 
.................... 	r1=SPI_READ(0xFF); 
.................... 	for( i=0;i<0x0fff;i++) { 
.................... 		r1=SPI_READ(0xFF);// digest prior operation 
.................... 		if (r1!=0x00) break; 
.................... 	} 
....................  
.................... 	if(size > bytes_posted){ 
.................... 		/// data spanned block so we need to upadte next block as well 
.................... 		size=size-bytes_posted; 
.................... 		block_address=block_address+512;/// advance a block 
....................  
.................... 		address=address+bytes_posted; /// move address ptr forward 
....................  
.................... 		goto next_block; 
.................... 	} 
....................  
....................  
.................... 	return(true); 
.................... } 
....................  
....................  
.................... #separate 
.................... void dump_block(){ 
.................... 	int in_buff[12],c,i,j; 
.................... 	int32 read_address; 
.................... 	char buff[MMC_BUFF_SIZE+1]; 
.................... 	for(i=0;i<12;i++)in_buff[i]=0; 
.................... 	printf("\n\r Input Start address:"); 
.................... 	j=0; 
.................... 	do { 
.................... 		c=getc(); 
.................... 		in_buff[j++]=c; 
.................... 		putc(c); 
.................... 	} 
.................... 	while(c!=13); 
.................... 	in_buff[j-1]=0; 
....................  
.................... 	read_address=atoint32(in_buff); 
.................... 	if (read_BLOCK(read_address,buff)==true){ 
.................... 		printf(" BLOCK\n\r"); 
.................... 		for(j=0;j<MMC_BUFF_SIZE;j=j+8){ 
.................... 			printf("%4LX ",read_address+j); 
.................... 			for(i=0;i<8;i++)printf(" %2X",buff[i+j]); 
.................... 			printf("\n\r"); 
....................  
.................... 		} 
.................... 	} 
.................... 	else printf("\n\r read_BLOCK failed"); 
....................  
.................... } 
....................  
....................  
.................... #separate 
.................... int32 cluster_addr(int fnbr,int mode){ 
.................... 	int32 address; 
.................... 	char buff[2]; //// buffer for 2 byte ptrs 
.................... 	///// returns the physical address in the data area of the data pointed to by either the 
.................... 	///// root cluster or the next cluster in the chain 
.................... 	///// 
.................... 	///// if ROOT_CLUSTER is called then this routine returns the address of the first cluster 
.................... 	///// and assigns this_cluster_ptr and next_cluster_ptr 
.................... 	///// 
.................... 	///// if NEXT_CLUSTER is called then this routine returns the address of the next cluster 
.................... 	///// using the existing next_cluster ptr number 
.................... 	///// and moves the existing next_cluster ptr number into this_cluster 
.................... 	///// and assigns the new next cluster ptr number (FFFF) if at the end of chain 
.................... 	///// if NEXT_CLUSTER is called and the next_cluster_ptr number is FFFF 
.................... 	///// an address of FFFFFFFF is returned 
....................  
.................... 	///// uses the globals cluster_size_bytes,data_area_address 
.................... 	//// file struct has the base=root cluster ptr, current=this cluster ptr ,next =cluster chain ptr 
....................  
.................... 	//// !!!! a call with NEXT_cluster must have a valid next_cluster_ptr value 
.................... 	//// !!!! a call to THIS CLUSTER must have a valid this_cluster_ptr 
....................  
.................... 	//// !!!! Fopen logic considers the cluster prt in the directory tile 
.................... 	//// to be a next=next_cluster_ptr so NEXT_CLUSTER is used to calc the physical address 
.................... 	//// of the first root cluster this also assigns the current=this_cluster_ptr 
.................... 	/// and fetches the next cluster prt 
.................... 	//// 
.................... 	#IF MMC_CLUSTER_TRACE // if true prints to serial port 
.................... 		printf("\n\r cluster addr>> next_cluster_ptr= %lu this_cluster=%lu \r\n",file[fnbr].next_cluster_ptr,file[fnbr].this_cluster_ptr); 
.................... 	#ENDIF 
.................... 	if (mode==NEXT_CLUSTER){ 
0878:  MOVLB  1
087A:  DECFSZ x55,W
087C:  BRA    0A9E
.................... 		///access the next cluster in the chain 
.................... 		/// requires a valid this_cluster_ptr number and a valid next_cluster_ptr number 
....................  
.................... 		if(file[fnbr].next_cluster_ptr==0xFFFF){ 
087E:  MOVF   x54,W
0880:  MULLW  3D
0882:  MOVF   FF3,W
0884:  CLRF   x5D
0886:  MOVWF  x5C
0888:  MOVLW  29
088A:  ADDWF  x5C,W
088C:  MOVWF  01
088E:  MOVLW  00
0890:  ADDWFC x5D,W
0892:  MOVWF  03
0894:  MOVF   01,W
0896:  ADDLW  22
0898:  MOVWF  FE9
089A:  MOVLW  00
089C:  ADDWFC 03,W
089E:  MOVWF  FEA
08A0:  MOVFF  FEC,15F
08A4:  MOVF   FED,F
08A6:  MOVFF  FEF,15E
08AA:  INCFSZ x5E,W
08AC:  BRA    08BE
08AE:  INCFSZ x5F,W
08B0:  BRA    08BE
.................... 			#IF MMC_CLUSTER_TRACE // if true prints to serial port 
.................... 				printf("last cluster"); 
.................... 			#ENDIF 
.................... 			address=0XFFFFFFFF; 
08B2:  MOVLW  FF
08B4:  MOVWF  x59
08B6:  MOVWF  x58
08B8:  MOVWF  x57
08BA:  MOVWF  x56
.................... 		} 
.................... 		else{ 
08BC:  BRA    0A9E
.................... 			if(set_BLOCKLEN((int32)2)==false) return(35); /// set up to read 2 bytes 
08BE:  CLRF   x63
08C0:  CLRF   x62
08C2:  CLRF   x61
08C4:  MOVLW  02
08C6:  MOVWF  x60
08C8:  MOVLB  0
08CA:  RCALL  02A6
08CC:  MOVF   01,F
08CE:  BNZ   08DC
08D0:  MOVLW  23
08D2:  MOVWF  00
08D4:  CLRF   01
08D6:  CLRF   02
08D8:  CLRF   03
08DA:  BRA    0CE8
.................... 			if(read_BLOCK(fat1_address+(file[fnbr].next_cluster_ptr)*2,buff)==false) return(33); 
08DC:  MOVLB  1
08DE:  MOVF   x54,W
08E0:  MULLW  3D
08E2:  MOVF   FF3,W
08E4:  CLRF   x5D
08E6:  MOVWF  x5C
08E8:  MOVLW  29
08EA:  ADDWF  x5C,W
08EC:  MOVWF  01
08EE:  MOVLW  00
08F0:  ADDWFC x5D,W
08F2:  MOVWF  03
08F4:  MOVF   01,W
08F6:  ADDLW  22
08F8:  MOVWF  FE9
08FA:  MOVLW  00
08FC:  ADDWFC 03,W
08FE:  MOVWF  FEA
0900:  MOVFF  FEC,15F
0904:  MOVF   FED,F
0906:  MOVFF  FEF,15E
090A:  BCF    FD8.0
090C:  RLCF   x5E,W
090E:  MOVWF  02
0910:  RLCF   x5F,W
0912:  MOVWF  03
0914:  MOVF   02,W
0916:  ADDWF  08,W
0918:  MOVWF  x60
091A:  MOVF   03,W
091C:  ADDWFC 09,W
091E:  MOVWF  x61
0920:  MOVLW  00
0922:  ADDWFC 0A,W
0924:  MOVWF  x62
0926:  MOVLW  00
0928:  ADDWFC 0B,W
092A:  MOVWF  x63
092C:  MOVWF  x67
092E:  MOVFF  162,166
0932:  MOVFF  161,165
0936:  MOVFF  160,164
093A:  MOVLW  01
093C:  MOVWF  x69
093E:  MOVLW  5A
0940:  MOVWF  x68
0942:  MOVLB  0
0944:  RCALL  02FC
0946:  MOVF   01,F
0948:  BNZ   0956
094A:  MOVLW  21
094C:  MOVWF  00
094E:  CLRF   01
0950:  CLRF   02
0952:  CLRF   03
0954:  BRA    0CE8
.................... 			file[fnbr].this_cluster_ptr=file[fnbr].next_cluster_ptr; // update current with prev next in chain 
0956:  MOVLB  1
0958:  MOVF   x54,W
095A:  MULLW  3D
095C:  MOVF   FF3,W
095E:  CLRF   x5D
0960:  MOVWF  x5C
0962:  MOVLW  27
0964:  ADDWF  x5C,W
0966:  MOVWF  01
0968:  MOVLW  00
096A:  ADDWFC x5D,W
096C:  MOVWF  03
096E:  MOVF   01,W
0970:  ADDLW  22
0972:  MOVWF  01
0974:  MOVLW  00
0976:  ADDWFC 03,F
0978:  MOVFF  01,15E
097C:  MOVFF  03,15F
0980:  MOVF   x54,W
0982:  MULLW  3D
0984:  MOVF   FF3,W
0986:  CLRF   x61
0988:  MOVWF  x60
098A:  MOVLW  29
098C:  ADDWF  x60,W
098E:  MOVWF  01
0990:  MOVLW  00
0992:  ADDWFC x61,W
0994:  MOVWF  03
0996:  MOVF   01,W
0998:  ADDLW  22
099A:  MOVWF  FE9
099C:  MOVLW  00
099E:  ADDWFC 03,W
09A0:  MOVWF  FEA
09A2:  MOVFF  FEC,03
09A6:  MOVF   FED,F
09A8:  MOVFF  FEF,162
09AC:  MOVFF  15F,FEA
09B0:  MOVFF  15E,FE9
09B4:  MOVFF  03,FEC
09B8:  MOVF   FED,F
09BA:  MOVFF  162,FEF
.................... 			file[fnbr].next_cluster_ptr=make16(buff[1],buff[0]); /// update next in chain 
09BE:  MOVF   x54,W
09C0:  MULLW  3D
09C2:  MOVF   FF3,W
09C4:  CLRF   x5D
09C6:  MOVWF  x5C
09C8:  MOVLW  29
09CA:  ADDWF  x5C,W
09CC:  MOVWF  01
09CE:  MOVLW  00
09D0:  ADDWFC x5D,W
09D2:  MOVWF  03
09D4:  MOVF   01,W
09D6:  ADDLW  22
09D8:  MOVWF  FE9
09DA:  MOVLW  00
09DC:  ADDWFC 03,W
09DE:  MOVWF  FEA
09E0:  MOVFF  15B,FEC
09E4:  MOVF   FED,F
09E6:  MOVFF  15A,FEF
....................  
.................... 			address=((int32)file[fnbr].this_cluster_ptr-(int32)2)*(int32)cluster_size_bytes+ 
.................... 			data_area_address; 
09EA:  MOVF   x54,W
09EC:  MULLW  3D
09EE:  MOVF   FF3,W
09F0:  CLRF   x5D
09F2:  MOVWF  x5C
09F4:  MOVLW  27
09F6:  ADDWF  x5C,W
09F8:  MOVWF  01
09FA:  MOVLW  00
09FC:  ADDWFC x5D,W
09FE:  MOVWF  03
0A00:  MOVF   01,W
0A02:  ADDLW  22
0A04:  MOVWF  FE9
0A06:  MOVLW  00
0A08:  ADDWFC 03,W
0A0A:  MOVWF  FEA
0A0C:  MOVFF  FEC,03
0A10:  MOVF   FED,F
0A12:  MOVFF  FEF,15E
0A16:  MOVFF  03,15F
0A1A:  CLRF   x60
0A1C:  CLRF   x61
0A1E:  MOVLW  02
0A20:  SUBWF  x5E,W
0A22:  MOVWF  x62
0A24:  MOVLW  00
0A26:  SUBWFB 03,W
0A28:  MOVWF  x63
0A2A:  MOVLW  00
0A2C:  SUBWFB x60,W
0A2E:  MOVWF  x64
0A30:  MOVLW  00
0A32:  SUBWFB x61,W
0A34:  MOVWF  x65
0A36:  MOVFF  06,00
0A3A:  MOVFF  07,01
0A3E:  CLRF   02
0A40:  CLRF   03
0A42:  MOVFF  03,169
0A46:  MOVFF  02,168
0A4A:  MOVFF  07,167
0A4E:  MOVFF  06,166
0A52:  MOVFF  FEA,16B
0A56:  MOVFF  FE9,16A
0A5A:  MOVWF  x6F
0A5C:  MOVFF  164,16E
0A60:  MOVFF  163,16D
0A64:  MOVFF  162,16C
0A68:  MOVFF  03,173
0A6C:  MOVFF  02,172
0A70:  MOVFF  07,171
0A74:  MOVFF  06,170
0A78:  MOVLB  0
0A7A:  RCALL  03E8
0A7C:  MOVFF  16B,FEA
0A80:  MOVFF  16A,FE9
0A84:  MOVF   14,W
0A86:  MOVLB  1
0A88:  ADDWF  00,W
0A8A:  MOVWF  x56
0A8C:  MOVF   15,W
0A8E:  ADDWFC 01,W
0A90:  MOVWF  x57
0A92:  MOVF   16,W
0A94:  ADDWFC 02,W
0A96:  MOVWF  x58
0A98:  MOVF   17,W
0A9A:  ADDWFC 03,W
0A9C:  MOVWF  x59
....................  
.................... 		} 
.................... 	} 
.................... 	if (mode==ROOT_CLUSTER){ 
0A9E:  MOVF   x55,F
0AA0:  BTFSS  FD8.2
0AA2:  BRA    0C8A
.................... 		//// root_cluster_ptr was assigned from the file tile in fopen 
.................... 		file[fnbr].this_cluster_ptr=file[fnbr].root_cluster_ptr; 
0AA4:  MOVF   x54,W
0AA6:  MULLW  3D
0AA8:  MOVF   FF3,W
0AAA:  CLRF   x5D
0AAC:  MOVWF  x5C
0AAE:  MOVLW  27
0AB0:  ADDWF  x5C,W
0AB2:  MOVWF  01
0AB4:  MOVLW  00
0AB6:  ADDWFC x5D,W
0AB8:  MOVWF  03
0ABA:  MOVF   01,W
0ABC:  ADDLW  22
0ABE:  MOVWF  01
0AC0:  MOVLW  00
0AC2:  ADDWFC 03,F
0AC4:  MOVFF  01,15E
0AC8:  MOVFF  03,15F
0ACC:  MOVF   x54,W
0ACE:  MULLW  3D
0AD0:  MOVF   FF3,W
0AD2:  CLRF   x61
0AD4:  MOVWF  x60
0AD6:  MOVLW  25
0AD8:  ADDWF  x60,W
0ADA:  MOVWF  01
0ADC:  MOVLW  00
0ADE:  ADDWFC x61,W
0AE0:  MOVWF  03
0AE2:  MOVF   01,W
0AE4:  ADDLW  22
0AE6:  MOVWF  FE9
0AE8:  MOVLW  00
0AEA:  ADDWFC 03,W
0AEC:  MOVWF  FEA
0AEE:  MOVFF  FEC,03
0AF2:  MOVF   FED,F
0AF4:  MOVFF  FEF,162
0AF8:  MOVFF  15F,FEA
0AFC:  MOVFF  15E,FE9
0B00:  MOVFF  03,FEC
0B04:  MOVF   FED,F
0B06:  MOVFF  162,FEF
.................... 		if(set_BLOCKLEN((int32)2)==false) return(35); /// set up to read 2 bytes 
0B0A:  CLRF   x63
0B0C:  CLRF   x62
0B0E:  CLRF   x61
0B10:  MOVLW  02
0B12:  MOVWF  x60
0B14:  MOVLB  0
0B16:  CALL   02A6
0B1A:  MOVF   01,F
0B1C:  BNZ   0B2A
0B1E:  MOVLW  23
0B20:  MOVWF  00
0B22:  CLRF   01
0B24:  CLRF   02
0B26:  CLRF   03
0B28:  BRA    0CE8
.................... 		if(read_BLOCK(fat1_address+(file[fnbr].this_cluster_ptr)*2,buff)==false) return(33); 
0B2A:  MOVLB  1
0B2C:  MOVF   x54,W
0B2E:  MULLW  3D
0B30:  MOVF   FF3,W
0B32:  CLRF   x5D
0B34:  MOVWF  x5C
0B36:  MOVLW  27
0B38:  ADDWF  x5C,W
0B3A:  MOVWF  01
0B3C:  MOVLW  00
0B3E:  ADDWFC x5D,W
0B40:  MOVWF  03
0B42:  MOVF   01,W
0B44:  ADDLW  22
0B46:  MOVWF  FE9
0B48:  MOVLW  00
0B4A:  ADDWFC 03,W
0B4C:  MOVWF  FEA
0B4E:  MOVFF  FEC,15F
0B52:  MOVF   FED,F
0B54:  MOVFF  FEF,15E
0B58:  BCF    FD8.0
0B5A:  RLCF   x5E,W
0B5C:  MOVWF  02
0B5E:  RLCF   x5F,W
0B60:  MOVWF  03
0B62:  MOVF   02,W
0B64:  ADDWF  08,W
0B66:  MOVWF  x60
0B68:  MOVF   03,W
0B6A:  ADDWFC 09,W
0B6C:  MOVWF  x61
0B6E:  MOVLW  00
0B70:  ADDWFC 0A,W
0B72:  MOVWF  x62
0B74:  MOVLW  00
0B76:  ADDWFC 0B,W
0B78:  MOVWF  x63
0B7A:  MOVWF  x67
0B7C:  MOVFF  162,166
0B80:  MOVFF  161,165
0B84:  MOVFF  160,164
0B88:  MOVLW  01
0B8A:  MOVWF  x69
0B8C:  MOVLW  5A
0B8E:  MOVWF  x68
0B90:  MOVLB  0
0B92:  CALL   02FC
0B96:  MOVF   01,F
0B98:  BNZ   0BA6
0B9A:  MOVLW  21
0B9C:  MOVWF  00
0B9E:  CLRF   01
0BA0:  CLRF   02
0BA2:  CLRF   03
0BA4:  BRA    0CE8
.................... 		file[fnbr].next_cluster_ptr=make16(buff[1],buff[0]); /// update next in chain 
0BA6:  MOVLB  1
0BA8:  MOVF   x54,W
0BAA:  MULLW  3D
0BAC:  MOVF   FF3,W
0BAE:  CLRF   x5D
0BB0:  MOVWF  x5C
0BB2:  MOVLW  29
0BB4:  ADDWF  x5C,W
0BB6:  MOVWF  01
0BB8:  MOVLW  00
0BBA:  ADDWFC x5D,W
0BBC:  MOVWF  03
0BBE:  MOVF   01,W
0BC0:  ADDLW  22
0BC2:  MOVWF  FE9
0BC4:  MOVLW  00
0BC6:  ADDWFC 03,W
0BC8:  MOVWF  FEA
0BCA:  MOVFF  15B,FEC
0BCE:  MOVF   FED,F
0BD0:  MOVFF  15A,FEF
.................... 		address=((int32)file[fnbr].this_cluster_ptr-(int32)2)*(int32)cluster_size_bytes+ 
.................... 		data_area_address; 
0BD4:  MOVF   x54,W
0BD6:  MULLW  3D
0BD8:  MOVF   FF3,W
0BDA:  CLRF   x5D
0BDC:  MOVWF  x5C
0BDE:  MOVLW  27
0BE0:  ADDWF  x5C,W
0BE2:  MOVWF  01
0BE4:  MOVLW  00
0BE6:  ADDWFC x5D,W
0BE8:  MOVWF  03
0BEA:  MOVF   01,W
0BEC:  ADDLW  22
0BEE:  MOVWF  FE9
0BF0:  MOVLW  00
0BF2:  ADDWFC 03,W
0BF4:  MOVWF  FEA
0BF6:  MOVFF  FEC,03
0BFA:  MOVF   FED,F
0BFC:  MOVFF  FEF,15E
0C00:  MOVFF  03,15F
0C04:  CLRF   x60
0C06:  CLRF   x61
0C08:  MOVLW  02
0C0A:  SUBWF  x5E,W
0C0C:  MOVWF  x62
0C0E:  MOVLW  00
0C10:  SUBWFB 03,W
0C12:  MOVWF  x63
0C14:  MOVLW  00
0C16:  SUBWFB x60,W
0C18:  MOVWF  x64
0C1A:  MOVLW  00
0C1C:  SUBWFB x61,W
0C1E:  MOVWF  x65
0C20:  MOVFF  06,00
0C24:  MOVFF  07,01
0C28:  CLRF   02
0C2A:  CLRF   03
0C2C:  MOVFF  03,169
0C30:  MOVFF  02,168
0C34:  MOVFF  07,167
0C38:  MOVFF  06,166
0C3C:  MOVFF  FEA,16B
0C40:  MOVFF  FE9,16A
0C44:  MOVWF  x6F
0C46:  MOVFF  164,16E
0C4A:  MOVFF  163,16D
0C4E:  MOVFF  162,16C
0C52:  MOVFF  03,173
0C56:  MOVFF  02,172
0C5A:  MOVFF  07,171
0C5E:  MOVFF  06,170
0C62:  MOVLB  0
0C64:  CALL   03E8
0C68:  MOVFF  16B,FEA
0C6C:  MOVFF  16A,FE9
0C70:  MOVF   14,W
0C72:  MOVLB  1
0C74:  ADDWF  00,W
0C76:  MOVWF  x56
0C78:  MOVF   15,W
0C7A:  ADDWFC 01,W
0C7C:  MOVWF  x57
0C7E:  MOVF   16,W
0C80:  ADDWFC 02,W
0C82:  MOVWF  x58
0C84:  MOVF   17,W
0C86:  ADDWFC 03,W
0C88:  MOVWF  x59
....................  
.................... 	} 
....................  
.................... 	// printf("clust addr call fnbr=%u blk_size=%lu",fnbr,file[fnbr].rec_size); 
....................  
.................... 	if(set_BLOCKLEN(file[fnbr].rec_size)==false) return(37); /// reset to original rec_size 
0C8A:  MOVF   x54,W
0C8C:  MULLW  3D
0C8E:  MOVF   FF3,W
0C90:  CLRF   x5D
0C92:  MOVWF  x5C
0C94:  MOVLW  3B
0C96:  ADDWF  x5C,W
0C98:  MOVWF  01
0C9A:  MOVLW  00
0C9C:  ADDWFC x5D,W
0C9E:  MOVWF  03
0CA0:  MOVF   01,W
0CA2:  ADDLW  22
0CA4:  MOVWF  FE9
0CA6:  MOVLW  00
0CA8:  ADDWFC 03,W
0CAA:  MOVWF  FEA
0CAC:  MOVFF  FEC,15F
0CB0:  MOVF   FED,F
0CB2:  MOVFF  FEF,15E
0CB6:  CLRF   x63
0CB8:  CLRF   x62
0CBA:  MOVFF  15F,161
0CBE:  MOVFF  15E,160
0CC2:  MOVLB  0
0CC4:  CALL   02A6
0CC8:  MOVF   01,F
0CCA:  BNZ   0CD8
0CCC:  MOVLW  25
0CCE:  MOVWF  00
0CD0:  CLRF   01
0CD2:  CLRF   02
0CD4:  CLRF   03
0CD6:  BRA    0CE8
....................  
.................... 	#IF MMC_CLUSTER_TRACE // if true prints to serial port 
.................... 		printf("\n\r cluster addr>> next_cluster_ptr*= %lu this_cluster*=%lu \r\n",file[fnbr].next_cluster_ptr,file[fnbr].this_cluster_ptr); 
.................... 	#ENDIF return(address); 
0CD8:  MOVFF  156,00
0CDC:  MOVFF  157,01
0CE0:  MOVFF  158,02
0CE4:  MOVFF  159,03
.................... } 
0CE8:  RETLW  00
....................  
....................  
.................... /////////////////////////////////////////////////////////////////////////////////// 
.................... ///////////////////////// OPEN FILE /////////////////////////////////////////// 
.................... /////////////////////////////////////////////////////////////////////////////////// 
.................... #separate 
.................... int open_file(int fnbr,char *fname,int16 rec_length){ 
.................... 	int32 dir_addr_ptr; 
.................... 	int16 bytes_read; 
.................... 	int i,ptr1,ptr2,lnf_tiles,j; 
.................... 	char file_name[12]; 
.................... 	int attribute,directory,archive; 
.................... 	char tmp; 
.................... 	char buff[32]; //// buffer for 32 byte tiles 
....................  
.................... 	int level; /// level in the directory structure 0 is top 
.................... 	/////// directory is searched and if file is found 
....................  
.................... 	////// 
.................... 	////// init_MMC(tries) must be called first 
.................... 	////// uses globals root_dir_address 
....................  
.................... 	//start by searching the root directory for folder or file 
....................  
.................... 	/// assign an inital next_cluster_ptr in the root directory 
.................... 	file[fnbr].next_cluster_ptr=0; 
*
0D88:  MOVLB  1
0D8A:  MOVF   x0F,W
0D8C:  MULLW  3D
0D8E:  MOVF   FF3,W
0D90:  CLRF   x51
0D92:  MOVWF  x50
0D94:  MOVLW  29
0D96:  ADDWF  x50,W
0D98:  MOVWF  01
0D9A:  MOVLW  00
0D9C:  ADDWFC x51,W
0D9E:  MOVWF  03
0DA0:  MOVF   01,W
0DA2:  ADDLW  22
0DA4:  MOVWF  FE9
0DA6:  MOVLW  00
0DA8:  ADDWFC 03,W
0DAA:  MOVWF  FEA
0DAC:  CLRF   FEC
0DAE:  MOVF   FED,F
0DB0:  CLRF   FEF
.................... 	file[fnbr].this_cluster_ptr=0; 
0DB2:  MOVF   x0F,W
0DB4:  MULLW  3D
0DB6:  MOVF   FF3,W
0DB8:  CLRF   x51
0DBA:  MOVWF  x50
0DBC:  MOVLW  27
0DBE:  ADDWF  x50,W
0DC0:  MOVWF  01
0DC2:  MOVLW  00
0DC4:  ADDWFC x51,W
0DC6:  MOVWF  03
0DC8:  MOVF   01,W
0DCA:  ADDLW  22
0DCC:  MOVWF  FE9
0DCE:  MOVLW  00
0DD0:  ADDWFC 03,W
0DD2:  MOVWF  FEA
0DD4:  CLRF   FEC
0DD6:  MOVF   FED,F
0DD8:  CLRF   FEF
....................  
.................... 	dir_addr_ptr=root_dir_address; 
0DDA:  MOVFF  13,117
0DDE:  MOVFF  12,116
0DE2:  MOVFF  11,115
0DE6:  MOVFF  10,114
.................... 	file_name[11]=0; 
0DEA:  CLRF   x2A
.................... 	level=0; 
0DEC:  CLRF   x4F
.................... 	ptr1=0; 
0DEE:  CLRF   x1B
.................... 	ptr2=0; 
0DF0:  CLRF   x1C
.................... 	bytes_read=0; //// byte read so far in this cluster 
0DF2:  CLRF   x19
0DF4:  CLRF   x18
....................  
.................... 	read_directory: 
.................... 	/// extract the directory levels(folders) 
.................... 	while ((fname[ptr2]!='/') && (fname[ptr2]!='\\') && (fname[ptr2]!='\0') && (fname[ptr2]!='.') ){ 
0DF6:  CLRF   03
0DF8:  MOVF   x1C,W
0DFA:  ADDWF  x10,W
0DFC:  MOVWF  FE9
0DFE:  MOVF   x11,W
0E00:  ADDWFC 03,W
0E02:  MOVWF  FEA
0E04:  MOVF   FEF,W
0E06:  SUBLW  2F
0E08:  BZ    0E56
0E0A:  CLRF   03
0E0C:  MOVF   x1C,W
0E0E:  ADDWF  x10,W
0E10:  MOVWF  FE9
0E12:  MOVF   x11,W
0E14:  ADDWFC 03,W
0E16:  MOVWF  FEA
0E18:  MOVF   FEF,W
0E1A:  SUBLW  5C
0E1C:  BZ    0E56
0E1E:  CLRF   03
0E20:  MOVF   x1C,W
0E22:  ADDWF  x10,W
0E24:  MOVWF  FE9
0E26:  MOVF   x11,W
0E28:  ADDWFC 03,W
0E2A:  MOVWF  FEA
0E2C:  MOVF   FEF,F
0E2E:  BZ    0E56
0E30:  CLRF   03
0E32:  MOVF   x1C,W
0E34:  ADDWF  x10,W
0E36:  MOVWF  FE9
0E38:  MOVF   x11,W
0E3A:  ADDWFC 03,W
0E3C:  MOVWF  FEA
0E3E:  MOVF   FEF,W
0E40:  SUBLW  2E
0E42:  BZ    0E56
.................... 		// a dos directory (folder) name can not exceed 8 chars 
.................... 		if ((ptr2-ptr1)>7) return (20); 
0E44:  MOVF   x1B,W
0E46:  SUBWF  x1C,W
0E48:  SUBLW  07
0E4A:  BC    0E52
0E4C:  MOVLW  14
0E4E:  MOVWF  01
0E50:  BRA    13BE
.................... 		ptr2++; 
0E52:  INCF   x1C,F
.................... 	} 
.................... 	#IF MMC_OPEN_TRACE 
0E54:  BRA    0DF6
.................... 		printf("\n\r fopen ptr1=%u ptr2=%u ",ptr1,ptr2); 
.................... 	#ENDIF 
....................  
.................... 	if (ptr2==0){ ptr2=1;ptr1=1;goto read_directory;} /// skip a leading '/' or '\' 
0E56:  MOVF   x1C,F
0E58:  BNZ   0E62
0E5A:  MOVLW  01
0E5C:  MOVWF  x1C
0E5E:  MOVWF  x1B
0E60:  BRA    0DF6
.................... 	if ((ptr2-ptr1)==0) return (21); 
0E62:  MOVF   x1B,W
0E64:  SUBWF  x1C,W
0E66:  BNZ   0E6E
0E68:  MOVLW  15
0E6A:  MOVWF  01
0E6C:  BRA    13BE
....................  
.................... 	// ptr1 is the chars processed so far 
.................... 	// ptr2 is the position of '/' or '\' or '.' or '\0' 
.................... 	// prepare the file or directory name fomat is cccccccceee 
.................... 	// c is a valid letter or blank eee is extension or blank 
.................... 	// a directory name is 'cccccccc ' a file 'cccccccceee' always 11 chars 
.................... 	for(i=0;i<11;i++)file_name[i]=32;//blank 
0E6E:  CLRF   x1A
0E70:  MOVF   x1A,W
0E72:  SUBLW  0A
0E74:  BNC   0E8C
0E76:  CLRF   03
0E78:  MOVF   x1A,W
0E7A:  ADDLW  1F
0E7C:  MOVWF  FE9
0E7E:  MOVLW  01
0E80:  ADDWFC 03,W
0E82:  MOVWF  FEA
0E84:  MOVLW  20
0E86:  MOVWF  FEF
0E88:  INCF   x1A,F
0E8A:  BRA    0E70
.................... 	file_name[11]=0; 
0E8C:  CLRF   x2A
.................... 	i=0; 
0E8E:  CLRF   x1A
.................... 	while(ptr1<ptr2){ 
0E90:  MOVF   x1C,W
0E92:  SUBWF  x1B,W
0E94:  BC    0ED6
.................... 		// extract the name 
....................  
.................... 		tmp=fname[ptr1]; 
0E96:  CLRF   03
0E98:  MOVF   x1B,W
0E9A:  ADDWF  x10,W
0E9C:  MOVWF  FE9
0E9E:  MOVF   x11,W
0EA0:  ADDWFC 03,W
0EA2:  MOVWF  FEA
0EA4:  MOVFF  FEF,12E
.................... 		tmp=TOUPPER(tmp); 
0EA8:  MOVF   x2E,W
0EAA:  SUBLW  60
0EAC:  BC    0EBA
0EAE:  MOVF   x2E,W
0EB0:  SUBLW  7A
0EB2:  BNC   0EBA
0EB4:  MOVF   x2E,W
0EB6:  ANDLW  DF
0EB8:  BRA    0EBC
0EBA:  MOVF   x2E,W
0EBC:  MOVWF  x2E
.................... 		file_name[i]=tmp; 
0EBE:  CLRF   03
0EC0:  MOVF   x1A,W
0EC2:  ADDLW  1F
0EC4:  MOVWF  FE9
0EC6:  MOVLW  01
0EC8:  ADDWFC 03,W
0ECA:  MOVWF  FEA
0ECC:  MOVFF  12E,FEF
.................... 		ptr1++;i++; 
0ED0:  INCF   x1B,F
0ED2:  INCF   x1A,F
.................... 	} 
0ED4:  BRA    0E90
.................... 	if(fname[ptr2]=='.'){ 
0ED6:  CLRF   03
0ED8:  MOVF   x1C,W
0EDA:  ADDWF  x10,W
0EDC:  MOVWF  FE9
0EDE:  MOVF   x11,W
0EE0:  ADDWFC 03,W
0EE2:  MOVWF  FEA
0EE4:  MOVF   FEF,W
0EE6:  SUBLW  2E
0EE8:  BNZ   0F42
.................... 		// extract the extension 
.................... 		i=8; 
0EEA:  MOVLW  08
0EEC:  MOVWF  x1A
.................... 		while((fname[ptr1]!='\0') && (i<12)){ 
0EEE:  CLRF   03
0EF0:  MOVF   x1B,W
0EF2:  ADDWF  x10,W
0EF4:  MOVWF  FE9
0EF6:  MOVF   x11,W
0EF8:  ADDWFC 03,W
0EFA:  MOVWF  FEA
0EFC:  MOVF   FEF,F
0EFE:  BZ    0F42
0F00:  MOVF   x1A,W
0F02:  SUBLW  0B
0F04:  BNC   0F42
.................... 			ptr1++; 
0F06:  INCF   x1B,F
.................... 			tmp=fname[ptr1]; 
0F08:  CLRF   03
0F0A:  MOVF   x1B,W
0F0C:  ADDWF  x10,W
0F0E:  MOVWF  FE9
0F10:  MOVF   x11,W
0F12:  ADDWFC 03,W
0F14:  MOVWF  FEA
0F16:  MOVFF  FEF,12E
.................... 			file_name[i]=TOUPPER(tmp); 
0F1A:  CLRF   03
0F1C:  MOVF   x1A,W
0F1E:  ADDLW  1F
0F20:  MOVWF  FE9
0F22:  MOVLW  01
0F24:  ADDWFC 03,W
0F26:  MOVWF  FEA
0F28:  MOVF   x2E,W
0F2A:  SUBLW  60
0F2C:  BC    0F3A
0F2E:  MOVF   x2E,W
0F30:  SUBLW  7A
0F32:  BNC   0F3A
0F34:  MOVF   x2E,W
0F36:  ANDLW  DF
0F38:  BRA    0F3C
0F3A:  MOVF   x2E,W
0F3C:  MOVWF  FEF
.................... 			i++; 
0F3E:  INCF   x1A,F
.................... 		} 
0F40:  BRA    0EEE
.................... 	} 
.................... 	ptr1++; 
0F42:  INCF   x1B,F
.................... 	ptr2=ptr1; // advance over the '\' or '/' so next pass starts correctly 
0F44:  MOVFF  11B,11C
.................... 	if (block_size!=(int32)32){ 
0F48:  MOVF   1C,W
0F4A:  SUBLW  20
0F4C:  BNZ   0F5A
0F4E:  MOVF   1D,F
0F50:  BNZ   0F5A
0F52:  MOVF   1E,F
0F54:  BNZ   0F5A
0F56:  MOVF   1F,F
0F58:  BZ    0F76
.................... 		if(set_BLOCKLEN((int32)32)==false) return(17); /// tiles are 32 bytes 
0F5A:  CLRF   x63
0F5C:  CLRF   x62
0F5E:  CLRF   x61
0F60:  MOVLW  20
0F62:  MOVWF  x60
0F64:  MOVLB  0
0F66:  CALL   02A6
0F6A:  MOVF   01,F
0F6C:  BNZ   0F78
0F6E:  MOVLW  11
0F70:  MOVWF  01
0F72:  MOVLB  1
0F74:  BRA    13BE
0F76:  MOVLB  0
.................... 	} 
.................... 	if (read_BLOCK(dir_addr_ptr,buff)==false) return(10); 
0F78:  MOVFF  117,167
0F7C:  MOVFF  116,166
0F80:  MOVFF  115,165
0F84:  MOVFF  114,164
0F88:  MOVLW  01
0F8A:  MOVLB  1
0F8C:  MOVWF  x69
0F8E:  MOVLW  2F
0F90:  MOVWF  x68
0F92:  MOVLB  0
0F94:  CALL   02FC
0F98:  MOVF   01,F
0F9A:  BNZ   0FA6
0F9C:  MOVLW  0A
0F9E:  MOVWF  01
0FA0:  MOVLB  1
0FA2:  BRA    13BE
0FA4:  MOVLB  0
....................  
.................... 	// decode the FAT16 entries 
.................... 	// a tile is 32 bytes 
.................... 	// std dos files take one tile 
.................... 	// a long file name has multiple tiles 
.................... 	// starting with the last down to the first and 
.................... 	// then a std dos tile is found 
.................... 	// byte 11 is 0x0f for LNF tiles and 0x00 for std 
.................... 	// we skip the LNF and goto STD tile 
....................  
.................... 	tile_decode: 
.................... 	lnf_tiles=0; 
0FA6:  MOVLB  1
0FA8:  CLRF   x1D
.................... 	if (buff[0]==0xE5) goto next_tile; ///0xE5 is the deleted file flag 
0FAA:  MOVF   x2F,W
0FAC:  SUBLW  E5
0FAE:  BNZ   0FB2
0FB0:  BRA    11A6
.................... 	if (buff[0]==0x00){ 
0FB2:  MOVF   x2F,F
0FB4:  BNZ   1018
.................... 		printf("\n\r file err [%s] not found \n\r",file_name); 
0FB6:  CLRF   x50
0FB8:  MOVF   x50,W
0FBA:  MOVLB  0
0FBC:  CALL   001A
0FC0:  MOVLB  1
0FC2:  INCF   x50,F
0FC4:  MOVWF  00
0FC6:  MOVF   00,W
0FC8:  BTFSS  F9E.4
0FCA:  BRA    0FC8
0FCC:  MOVWF  FAD
0FCE:  MOVLW  0D
0FD0:  SUBWF  x50,W
0FD2:  BNZ   0FB8
0FD4:  MOVLW  01
0FD6:  MOVWF  FEA
0FD8:  MOVLW  1F
0FDA:  MOVWF  FE9
0FDC:  MOVLW  00
0FDE:  IORWF  FEF,W
0FE0:  BZ    0FF2
0FE2:  BTFSS  F9E.4
0FE4:  BRA    0FE2
0FE6:  MOVFF  FEF,FAD
0FEA:  INCF   FE9,F
0FEC:  BTFSC  FD8.2
0FEE:  INCF   FEA,F
0FF0:  BRA    0FDC
0FF2:  MOVLW  0F
0FF4:  MOVWF  x53
0FF6:  MOVF   x53,W
0FF8:  MOVLB  0
0FFA:  CALL   001A
0FFE:  MOVLB  1
1000:  INCF   x53,F
1002:  MOVWF  00
1004:  MOVF   00,W
1006:  BTFSS  F9E.4
1008:  BRA    1006
100A:  MOVWF  FAD
100C:  MOVLW  1D
100E:  SUBWF  x53,W
1010:  BNZ   0FF6
.................... 		return(11); /// file not found 
1012:  MOVLW  0B
1014:  MOVWF  01
1016:  BRA    13BE
.................... 	} 
.................... 	if (buff[11]==0x0F){ 
1018:  MOVF   x3A,W
101A:  SUBLW  0F
101C:  BNZ   10C4
.................... 		/// get number of LNF tiles 
.................... 		lnf_tiles=buff[0] & 0b00111111; 
101E:  MOVF   x2F,W
1020:  ANDLW  3F
1022:  MOVWF  x1D
.................... 		bytes_read=bytes_read+lnf_tiles*32; 
1024:  MOVF   x1D,W
1026:  MULLW  20
1028:  MOVF   FF3,W
102A:  ADDWF  x18,F
102C:  MOVLW  00
102E:  ADDWFC x19,F
.................... 		if(bytes_read>cluster_size_bytes){ 
1030:  MOVF   07,W
1032:  SUBWF  x19,W
1034:  BNC   108A
1036:  BNZ   103E
1038:  MOVF   x18,W
103A:  SUBWF  06,W
103C:  BC    108A
.................... 			// compute next cluster address next_cluster_ptr must be valid 
.................... 			// assigns this_cluster_ptr 
....................  
.................... 			dir_addr_ptr=cluster_addr(fnbr,NEXT_CLUSTER); 
103E:  MOVFF  10F,154
1042:  MOVLW  01
1044:  MOVWF  x55
1046:  MOVLB  0
1048:  RCALL  0878
104A:  MOVFF  03,117
104E:  MOVFF  02,116
1052:  MOVFF  01,115
1056:  MOVFF  00,114
.................... 			if (dir_addr_ptr==0xFFFFFF) return (22); 
105A:  MOVLB  1
105C:  INCFSZ x14,W
105E:  BRA    1072
1060:  INCFSZ x15,W
1062:  BRA    1072
1064:  INCFSZ x16,W
1066:  BRA    1072
1068:  MOVF   x17,F
106A:  BNZ   1072
106C:  MOVLW  16
106E:  MOVWF  01
1070:  BRA    13BE
.................... 			bytes_read=bytes_read-cluster_size_bytes; 
1072:  MOVF   06,W
1074:  SUBWF  x18,F
1076:  MOVF   07,W
1078:  SUBWFB x19,F
.................... 			dir_addr_ptr=dir_addr_ptr+bytes_read; 
107A:  MOVF   x18,W
107C:  ADDWF  x14,F
107E:  MOVF   x19,W
1080:  ADDWFC x15,F
1082:  MOVLW  00
1084:  ADDWFC x16,F
1086:  ADDWFC x17,F
.................... 		} 
.................... 		else{ 
1088:  BRA    109A
.................... 			dir_addr_ptr=dir_addr_ptr+lnf_tiles*32; 
108A:  MOVF   x1D,W
108C:  MULLW  20
108E:  MOVF   FF3,W
1090:  ADDWF  x14,F
1092:  MOVLW  00
1094:  ADDWFC x15,F
1096:  ADDWFC x16,F
1098:  ADDWFC x17,F
.................... 		} 
....................  
.................... 		//advance over the lnf tiles 
.................... 		/// test to see if we need next cluster in chain 
.................... 		if (read_BLOCK(dir_addr_ptr,buff)==false) return(31); 
109A:  MOVFF  117,167
109E:  MOVFF  116,166
10A2:  MOVFF  115,165
10A6:  MOVFF  114,164
10AA:  MOVLW  01
10AC:  MOVWF  x69
10AE:  MOVLW  2F
10B0:  MOVWF  x68
10B2:  MOVLB  0
10B4:  CALL   02FC
10B8:  MOVF   01,F
10BA:  BNZ   10C6
10BC:  MOVLW  1F
10BE:  MOVWF  01
10C0:  MOVLB  1
10C2:  BRA    13BE
10C4:  MOVLB  0
.................... 		/// !!! may read into next sector 
.................... 	} 
....................  
....................  
.................... 	/// check out the standard DOS tile 
.................... 	#IF MMC_OPEN_TRACE 
.................... 		printf("\n\r fname[%s] level=%u \n\r",file_name,level); 
.................... 		for (j=0;j<11;j++)printf("%c",buff[j]); 
.................... 	#ENDIF 
.................... 	if(strncmp(buff,file_name, 11)==0){ ///8.3 file name ex "FILE EXT" "FOLDER " 
10C6:  MOVLW  01
10C8:  MOVLB  1
10CA:  MOVWF  x51
10CC:  MOVLW  2F
10CE:  MOVWF  x50
10D0:  MOVLW  01
10D2:  MOVWF  x53
10D4:  MOVLW  1F
10D6:  MOVWF  x52
10D8:  MOVLW  0B
10DA:  MOVWF  x54
10DC:  MOVLB  0
10DE:  BRA    0CEA
10E0:  MOVF   01,F
10E2:  BNZ   11A8
.................... 		// we have a file type or a sub directory(folder) 
.................... 		// so we get the starting cluster number 
.................... 		attribute=buff[11]; 
10E4:  MOVFF  13A,12B
....................  
.................... 		file[fnbr].root_cluster_ptr=make16(buff[27],buff[26]);/// assign initial cluster ptr 
10E8:  MOVLB  1
10EA:  MOVF   x0F,W
10EC:  MULLW  3D
10EE:  MOVF   FF3,W
10F0:  CLRF   x51
10F2:  MOVWF  x50
10F4:  MOVLW  25
10F6:  ADDWF  x50,W
10F8:  MOVWF  01
10FA:  MOVLW  00
10FC:  ADDWFC x51,W
10FE:  MOVWF  03
1100:  MOVF   01,W
1102:  ADDLW  22
1104:  MOVWF  FE9
1106:  MOVLW  00
1108:  ADDWFC 03,W
110A:  MOVWF  FEA
110C:  MOVFF  14A,FEC
1110:  MOVF   FED,F
1112:  MOVFF  149,FEF
.................... 		/// if it is not a directory 
.................... 		/// it points to the begining of the file 
.................... 		/// cluster chain 
....................  
....................  
....................  
.................... 		if ((attribute & 0b00010000)>0)directory=true; 
1116:  MOVF   x2B,W
1118:  ANDLW  10
111A:  BZ    1122
111C:  MOVLW  01
111E:  MOVWF  x2C
.................... 		else directory=false; 
1120:  BRA    1124
1122:  CLRF   x2C
.................... 		if ((attribute & 0b00100000)>0 || attribute==0){ 
1124:  MOVF   x2B,W
1126:  ANDLW  20
1128:  BNZ   112E
112A:  MOVF   x2B,F
112C:  BNZ   11A2
.................... 			archive=true; //// we have our file 
112E:  MOVLW  01
1130:  MOVWF  x2D
....................  
.................... 			file[fnbr].size=make32(buff[31],buff[30],buff[29],buff[28]); 
1132:  MOVF   x0F,W
1134:  MULLW  3D
1136:  MOVF   FF3,W
1138:  CLRF   x51
113A:  MOVWF  x50
113C:  MOVLW  2F
113E:  ADDWF  x50,W
1140:  MOVWF  01
1142:  MOVLW  00
1144:  ADDWFC x51,W
1146:  MOVWF  03
1148:  MOVF   01,W
114A:  ADDLW  22
114C:  MOVWF  FE9
114E:  MOVLW  00
1150:  ADDWFC 03,W
1152:  MOVWF  FEA
1154:  MOVF   FEE,F
1156:  MOVF   FEE,F
1158:  MOVFF  14E,FEC
115C:  MOVF   FED,F
115E:  MOVFF  14D,FEF
1162:  MOVF   FED,F
1164:  MOVFF  14C,FEF
1168:  MOVF   FED,F
116A:  MOVFF  14B,FEF
.................... 			file[fnbr].dir_addr_ptr=dir_addr_ptr; ///save address of this files tile 
116E:  MOVF   x0F,W
1170:  MULLW  3D
1172:  MOVF   FF3,W
1174:  CLRF   x51
1176:  MOVWF  x50
1178:  MOVLW  21
117A:  ADDWF  x50,W
117C:  MOVWF  01
117E:  MOVLW  00
1180:  ADDWFC x51,W
1182:  MOVWF  03
1184:  MOVF   01,W
1186:  ADDLW  22
1188:  MOVWF  FE9
118A:  MOVLW  00
118C:  ADDWFC 03,W
118E:  MOVWF  FEA
1190:  MOVFF  114,FEF
1194:  MOVFF  115,FEC
1198:  MOVFF  116,FEC
119C:  MOVFF  117,FEC
.................... 			/// assign global value 
.................... 		} 
.................... 		else archive=false; 
11A0:  BRA    11A4
11A2:  CLRF   x2D
....................  
....................  
....................  
.................... 		goto match_found; 
11A4:  BRA    1256
11A6:  MOVLB  0
.................... 		// goto fill_table; // we have a match 
.................... 	} 
.................... 	next_tile: 
.................... 	bytes_read=bytes_read+32; 
11A8:  MOVLW  20
11AA:  MOVLB  1
11AC:  ADDWF  x18,F
11AE:  MOVLW  00
11B0:  ADDWFC x19,F
.................... 	if(bytes_read > cluster_size_bytes){ 
11B2:  MOVF   07,W
11B4:  SUBWF  x19,W
11B6:  BNC   120E
11B8:  BNZ   11C0
11BA:  MOVF   x18,W
11BC:  SUBWF  06,W
11BE:  BC    120E
.................... 		/// requires a valid next=next_cluster_ptr 
.................... 		// compute next cluster address and assign this cluster 
.................... 		dir_addr_ptr=cluster_addr(fnbr,NEXT_CLUSTER); 
11C0:  MOVFF  10F,154
11C4:  MOVLW  01
11C6:  MOVWF  x55
11C8:  MOVLB  0
11CA:  CALL   0878
11CE:  MOVFF  03,117
11D2:  MOVFF  02,116
11D6:  MOVFF  01,115
11DA:  MOVFF  00,114
.................... 		if (dir_addr_ptr==0xFFFFFF) return (23); 
11DE:  MOVLB  1
11E0:  INCFSZ x14,W
11E2:  BRA    11F6
11E4:  INCFSZ x15,W
11E6:  BRA    11F6
11E8:  INCFSZ x16,W
11EA:  BRA    11F6
11EC:  MOVF   x17,F
11EE:  BNZ   11F6
11F0:  MOVLW  17
11F2:  MOVWF  01
11F4:  BRA    13BE
.................... 		bytes_read=bytes_read-cluster_size_bytes; 
11F6:  MOVF   06,W
11F8:  SUBWF  x18,F
11FA:  MOVF   07,W
11FC:  SUBWFB x19,F
.................... 		dir_addr_ptr=dir_addr_ptr+bytes_read; 
11FE:  MOVF   x18,W
1200:  ADDWF  x14,F
1202:  MOVF   x19,W
1204:  ADDWFC x15,F
1206:  MOVLW  00
1208:  ADDWFC x16,F
120A:  ADDWFC x17,F
.................... 	} 
.................... 	else{ 
120C:  BRA    121A
.................... 		dir_addr_ptr=dir_addr_ptr+32; 
120E:  MOVLW  20
1210:  ADDWF  x14,F
1212:  MOVLW  00
1214:  ADDWFC x15,F
1216:  ADDWFC x16,F
1218:  ADDWFC x17,F
.................... 	} 
....................  
....................  
.................... 	dir_addr_ptr=dir_addr_ptr+32; 
121A:  MOVLW  20
121C:  ADDWF  x14,F
121E:  MOVLW  00
1220:  ADDWFC x15,F
1222:  ADDWFC x16,F
1224:  ADDWFC x17,F
....................  
.................... 	if (read_BLOCK(dir_addr_ptr,buff)==false) return(32); 
1226:  MOVFF  117,167
122A:  MOVFF  116,166
122E:  MOVFF  115,165
1232:  MOVFF  114,164
1236:  MOVLW  01
1238:  MOVWF  x69
123A:  MOVLW  2F
123C:  MOVWF  x68
123E:  MOVLB  0
1240:  CALL   02FC
1244:  MOVF   01,F
1246:  BNZ   1252
1248:  MOVLW  20
124A:  MOVWF  01
124C:  MOVLB  1
124E:  BRA    13BE
1250:  MOVLB  0
.................... 	goto tile_decode; 
1252:  BRA    0FA6
1254:  MOVLB  1
....................  
.................... 	match_found: 
.................... 	///// if we have a sub directory we need to cycle down a level 
.................... 	if (directory==true) { 
1256:  DECFSZ x2C,W
1258:  BRA    127C
.................... 		// compute the sub directory address 
.................... 		// compute this cluster address this_cluster_ptr must be valid 
.................... 		dir_addr_ptr=cluster_addr(fnbr,ROOT_CLUSTER); /// set physical addr of starting cluster 
125A:  MOVFF  10F,154
125E:  CLRF   x55
1260:  MOVLB  0
1262:  CALL   0878
1266:  MOVFF  03,117
126A:  MOVFF  02,116
126E:  MOVFF  01,115
1272:  MOVFF  00,114
.................... 		#IF MMC_OPEN_TRACE 
.................... 			printf("\n\r next_cluster_ptr=%lu \n\r ",file[fnbr].next_cluster_ptr); 
.................... 		#ENDIF 
.................... 		//printf("\n\r dir_addr_ptr=%lu",dir_addr_ptr); 
.................... 		// dir_addr_ptr=((int32)cluster_table[0]-(int32)2)*(int32)cluster_size_bytes+ 
.................... 		// data_area_address; 
.................... 		level++; 
1276:  MOVLB  1
1278:  INCF   x4F,F
.................... 		goto read_directory; 
127A:  BRA    0DF6
.................... 	} 
....................  
....................  
.................... 	// note record length must divide into 512 to align properly 
.................... 	if (rec_length<2) return(12); 
127C:  MOVF   x13,F
127E:  BNZ   128C
1280:  MOVF   x12,W
1282:  SUBLW  01
1284:  BNC   128C
1286:  MOVLW  0C
1288:  MOVWF  01
128A:  BRA    13BE
....................  
....................  
....................  
.................... 	/// get the initial file_addr_ptr 
....................  
.................... 	file[fnbr].addr_ptr=cluster_addr(fnbr,ROOT_CLUSTER); 
128C:  MOVF   x0F,W
128E:  MULLW  3D
1290:  MOVF   FF3,W
1292:  CLRF   x51
1294:  MOVWF  x50
1296:  MOVLW  2B
1298:  ADDWF  x50,W
129A:  MOVWF  01
129C:  MOVLW  00
129E:  ADDWFC x51,W
12A0:  MOVWF  03
12A2:  MOVF   01,W
12A4:  ADDLW  22
12A6:  MOVWF  01
12A8:  MOVLW  00
12AA:  ADDWFC 03,F
12AC:  MOVFF  01,152
12B0:  MOVFF  03,153
12B4:  MOVFF  10F,154
12B8:  CLRF   x55
12BA:  MOVLB  0
12BC:  CALL   0878
12C0:  MOVFF  153,FEA
12C4:  MOVFF  152,FE9
12C8:  MOVFF  00,FEF
12CC:  MOVFF  01,FEC
12D0:  MOVFF  02,FEC
12D4:  MOVFF  03,FEC
.................... 	file[fnbr].offset=0; //init bytes read from beginning of open file 
12D8:  MOVLB  1
12DA:  MOVF   x0F,W
12DC:  MULLW  3D
12DE:  MOVF   FF3,W
12E0:  CLRF   x51
12E2:  MOVWF  x50
12E4:  MOVLW  37
12E6:  ADDWF  x50,W
12E8:  MOVWF  01
12EA:  MOVLW  00
12EC:  ADDWFC x51,W
12EE:  MOVWF  03
12F0:  MOVF   01,W
12F2:  ADDLW  22
12F4:  MOVWF  FE9
12F6:  MOVLW  00
12F8:  ADDWFC 03,W
12FA:  MOVWF  FEA
12FC:  MOVF   FEE,F
12FE:  MOVF   FEE,F
1300:  CLRF   FEC
1302:  MOVF   FED,F
1304:  CLRF   FEF
1306:  MOVF   FED,F
1308:  CLRF   FEF
130A:  MOVF   FED,F
130C:  CLRF   FEF
.................... 	file[fnbr].cluster_offset=0; //init bytes read to beginning of the current cluster 
130E:  MOVF   x0F,W
1310:  MULLW  3D
1312:  MOVF   FF3,W
1314:  CLRF   x51
1316:  MOVWF  x50
1318:  MOVLW  33
131A:  ADDWF  x50,W
131C:  MOVWF  01
131E:  MOVLW  00
1320:  ADDWFC x51,W
1322:  MOVWF  03
1324:  MOVF   01,W
1326:  ADDLW  22
1328:  MOVWF  FE9
132A:  MOVLW  00
132C:  ADDWFC 03,W
132E:  MOVWF  FEA
1330:  MOVF   FEE,F
1332:  MOVF   FEE,F
1334:  CLRF   FEC
1336:  MOVF   FED,F
1338:  CLRF   FEF
133A:  MOVF   FED,F
133C:  CLRF   FEF
133E:  MOVF   FED,F
1340:  CLRF   FEF
.................... 	file[fnbr].rec_size=(int32)rec_length; /// assign file record size 
1342:  MOVF   x0F,W
1344:  MULLW  3D
1346:  MOVF   FF3,W
1348:  CLRF   x51
134A:  MOVWF  x50
134C:  MOVLW  3B
134E:  ADDWF  x50,W
1350:  MOVWF  01
1352:  MOVLW  00
1354:  ADDWFC x51,W
1356:  MOVWF  03
1358:  MOVF   01,W
135A:  ADDLW  22
135C:  MOVWF  FE9
135E:  MOVLW  00
1360:  ADDWFC 03,W
1362:  MOVWF  FEA
1364:  MOVFF  112,FEF
1368:  MOVFF  113,FEC
.................... 	#IF MMC_OPEN_TRACE 
.................... 		printf("root_cluster=%lu \n\r",file[fnbr].root_cluster_ptr); 
.................... 	#ENDIF 
....................  
.................... 	//printf("\n\r fopen %u rec size=%lu",fnbr,file[fnbr].rec_size); 
....................  
.................... 	if(set_BLOCKLEN(file[fnbr].rec_size)==false) return(13); 
136C:  MOVF   x0F,W
136E:  MULLW  3D
1370:  MOVF   FF3,W
1372:  CLRF   x51
1374:  MOVWF  x50
1376:  MOVLW  3B
1378:  ADDWF  x50,W
137A:  MOVWF  01
137C:  MOVLW  00
137E:  ADDWFC x51,W
1380:  MOVWF  03
1382:  MOVF   01,W
1384:  ADDLW  22
1386:  MOVWF  FE9
1388:  MOVLW  00
138A:  ADDWFC 03,W
138C:  MOVWF  FEA
138E:  MOVFF  FEC,153
1392:  MOVF   FED,F
1394:  MOVFF  FEF,152
1398:  CLRF   x63
139A:  CLRF   x62
139C:  MOVFF  153,161
13A0:  MOVFF  152,160
13A4:  MOVLB  0
13A6:  CALL   02A6
13AA:  MOVF   01,F
13AC:  BNZ   13B8
13AE:  MOVLW  0D
13B0:  MOVWF  01
13B2:  MOVLB  1
13B4:  BRA    13BE
13B6:  MOVLB  0
....................  
.................... 	return(0); 
13B8:  MOVLW  00
13BA:  MOVWF  01
13BC:  MOVLB  1
.................... } 
13BE:  MOVLB  0
13C0:  GOTO   1DB2 (RETURN)
....................  
.................... ////////////////////////////////////////////////////////////////////////////////// 
.................... ////////////////////////////// FILE READ /////////////////////////////////////// 
.................... ///////////////////////////////////////////////////////////////////////////////// 
.................... #separate 
.................... int file_read(int8 fnbr,char *buff){ 
.................... 	int32 address; 
.................... 	int32 nxt_cluster; 
.................... 	//// MMC allows a read to start and stop at any address but this file system 
.................... 	//// imposes a record size restriction the record size must divide into the 
.................... 	/// 512 block to allow writing of the records 
.................... 	/// rec_size must align with cluster boundary 2048 ...must be a divisor of 2048 
.................... 	/// find the cluster containing the offset 
.................... 	/// buff must be at least the size of the recordsize requested in the File open 
....................  
.................... 	//printf("foffset=%lu coffset=%lu ",file[fnbr].offset,file[fnbr].cluster_offset);////$$$$ 
....................  
.................... 	if ( file[fnbr].offset>=file[fnbr].size) return(10); /// already beyond eof 
*
151A:  MOVLB  1
151C:  MOVF   x0F,W
151E:  MULLW  3D
1520:  MOVF   FF3,W
1522:  CLRF   x1B
1524:  MOVWF  x1A
1526:  MOVLW  37
1528:  ADDWF  x1A,W
152A:  MOVWF  01
152C:  MOVLW  00
152E:  ADDWFC x1B,W
1530:  MOVWF  03
1532:  MOVF   01,W
1534:  ADDLW  22
1536:  MOVWF  FE9
1538:  MOVLW  00
153A:  ADDWFC 03,W
153C:  MOVWF  FEA
153E:  MOVFF  FEF,11C
1542:  MOVFF  FEC,11D
1546:  MOVFF  FEC,11E
154A:  MOVFF  FEC,11F
154E:  MOVF   x0F,W
1550:  MULLW  3D
1552:  MOVF   FF3,W
1554:  CLRF   x21
1556:  MOVWF  x20
1558:  MOVLW  2F
155A:  ADDWF  x20,W
155C:  MOVWF  01
155E:  MOVLW  00
1560:  ADDWFC x21,W
1562:  MOVWF  03
1564:  MOVF   01,W
1566:  ADDLW  22
1568:  MOVWF  FE9
156A:  MOVLW  00
156C:  ADDWFC 03,W
156E:  MOVWF  FEA
1570:  MOVFF  FEF,00
1574:  MOVFF  FEC,01
1578:  MOVFF  FEC,02
157C:  MOVFF  FEC,03
1580:  MOVF   03,W
1582:  SUBWF  x1F,W
1584:  BNC   15A4
1586:  BNZ   159E
1588:  MOVF   02,W
158A:  SUBWF  x1E,W
158C:  BNC   15A4
158E:  BNZ   159E
1590:  MOVF   01,W
1592:  SUBWF  x1D,W
1594:  BNC   15A4
1596:  BNZ   159E
1598:  MOVF   00,W
159A:  SUBWF  x1C,W
159C:  BNC   15A4
159E:  MOVLW  0A
15A0:  MOVWF  01
15A2:  BRA    1AF6
....................  
.................... 	if ( file[fnbr].offset + (int32) file[fnbr].rec_size > file[fnbr].cluster_offset + (int32) cluster_size_bytes){ 
15A4:  MOVF   x0F,W
15A6:  MULLW  3D
15A8:  MOVF   FF3,W
15AA:  CLRF   x1B
15AC:  MOVWF  x1A
15AE:  MOVLW  37
15B0:  ADDWF  x1A,W
15B2:  MOVWF  01
15B4:  MOVLW  00
15B6:  ADDWFC x1B,W
15B8:  MOVWF  03
15BA:  MOVF   01,W
15BC:  ADDLW  22
15BE:  MOVWF  FE9
15C0:  MOVLW  00
15C2:  ADDWFC 03,W
15C4:  MOVWF  FEA
15C6:  MOVFF  FEF,11C
15CA:  MOVFF  FEC,11D
15CE:  MOVFF  FEC,11E
15D2:  MOVFF  FEC,11F
15D6:  MOVF   x0F,W
15D8:  MULLW  3D
15DA:  MOVF   FF3,W
15DC:  CLRF   x21
15DE:  MOVWF  x20
15E0:  MOVLW  3B
15E2:  ADDWF  x20,W
15E4:  MOVWF  01
15E6:  MOVLW  00
15E8:  ADDWFC x21,W
15EA:  MOVWF  03
15EC:  MOVF   01,W
15EE:  ADDLW  22
15F0:  MOVWF  FE9
15F2:  MOVLW  00
15F4:  ADDWFC 03,W
15F6:  MOVWF  FEA
15F8:  MOVFF  FEC,03
15FC:  MOVF   FED,F
15FE:  MOVFF  FEF,00
1602:  MOVFF  03,01
1606:  CLRF   02
1608:  CLRF   03
160A:  MOVF   00,W
160C:  ADDWF  x1C,W
160E:  MOVWF  x22
1610:  MOVF   01,W
1612:  ADDWFC x1D,W
1614:  MOVWF  x23
1616:  MOVF   02,W
1618:  ADDWFC x1E,W
161A:  MOVWF  x24
161C:  MOVF   03,W
161E:  ADDWFC x1F,W
1620:  MOVWF  x25
1622:  MOVF   x0F,W
1624:  MULLW  3D
1626:  MOVF   FF3,W
1628:  CLRF   x27
162A:  MOVWF  x26
162C:  MOVLW  33
162E:  ADDWF  x26,W
1630:  MOVWF  01
1632:  MOVLW  00
1634:  ADDWFC x27,W
1636:  MOVWF  03
1638:  MOVF   01,W
163A:  ADDLW  22
163C:  MOVWF  FE9
163E:  MOVLW  00
1640:  ADDWFC 03,W
1642:  MOVWF  FEA
1644:  MOVFF  FEF,128
1648:  MOVFF  FEC,129
164C:  MOVFF  FEC,12A
1650:  MOVFF  FEC,12B
1654:  MOVFF  06,00
1658:  MOVFF  07,01
165C:  CLRF   02
165E:  CLRF   03
1660:  MOVF   x28,W
1662:  ADDWF  00,F
1664:  MOVF   x29,W
1666:  ADDWFC 01,F
1668:  MOVF   x2A,W
166A:  ADDWFC 02,F
166C:  MOVF   x2B,W
166E:  ADDWFC 03,F
1670:  MOVF   03,W
1672:  SUBWF  x25,W
1674:  BTFSS  FD8.0
1676:  BRA    1790
1678:  BNZ   1696
167A:  MOVF   02,W
167C:  SUBWF  x24,W
167E:  BTFSS  FD8.0
1680:  BRA    1790
1682:  BNZ   1696
1684:  MOVF   01,W
1686:  SUBWF  x23,W
1688:  BTFSS  FD8.0
168A:  BRA    1790
168C:  BNZ   1696
168E:  MOVF   x22,W
1690:  SUBWF  00,W
1692:  BTFSC  FD8.0
1694:  BRA    1790
.................... 		#IF MMC_READ_TRACE 
.................... 			printf("adv to next cluster"); 
.................... 		#ENDIF 
.................... 		/// need to advance to the next cluster 
.................... 		nxt_cluster=cluster_addr(fnbr,NEXT_CLUSTER); 
1696:  MOVFF  10F,154
169A:  MOVLW  01
169C:  MOVWF  x55
169E:  MOVLB  0
16A0:  CALL   0878
16A4:  MOVFF  03,119
16A8:  MOVFF  02,118
16AC:  MOVFF  01,117
16B0:  MOVFF  00,116
.................... 		if ( nxt_cluster!=0XFFFFFFFF) file[fnbr].addr_ptr=nxt_cluster; 
16B4:  MOVLB  1
16B6:  INCFSZ x16,W
16B8:  BRA    16C8
16BA:  INCFSZ x17,W
16BC:  BRA    16C8
16BE:  INCFSZ x18,W
16C0:  BRA    16C8
16C2:  INCFSZ x19,W
16C4:  BRA    16C8
16C6:  BRA    16FC
16C8:  MOVF   x0F,W
16CA:  MULLW  3D
16CC:  MOVF   FF3,W
16CE:  CLRF   x1B
16D0:  MOVWF  x1A
16D2:  MOVLW  2B
16D4:  ADDWF  x1A,W
16D6:  MOVWF  01
16D8:  MOVLW  00
16DA:  ADDWFC x1B,W
16DC:  MOVWF  03
16DE:  MOVF   01,W
16E0:  ADDLW  22
16E2:  MOVWF  FE9
16E4:  MOVLW  00
16E6:  ADDWFC 03,W
16E8:  MOVWF  FEA
16EA:  MOVFF  116,FEF
16EE:  MOVFF  117,FEC
16F2:  MOVFF  118,FEC
16F6:  MOVFF  119,FEC
.................... 		else return(11); /// last cluster in file reached 
16FA:  BRA    1702
16FC:  MOVLW  0B
16FE:  MOVWF  01
1700:  BRA    1AF6
....................  
.................... 		file[fnbr].cluster_offset=file[fnbr].cluster_offset+(int32)cluster_size_bytes; //foffset is the byte offset within the file 
1702:  MOVF   x0F,W
1704:  MULLW  3D
1706:  MOVF   FF3,W
1708:  CLRF   x1B
170A:  MOVWF  x1A
170C:  MOVLW  33
170E:  ADDWF  x1A,W
1710:  MOVWF  01
1712:  MOVLW  00
1714:  ADDWFC x1B,W
1716:  MOVWF  03
1718:  MOVF   01,W
171A:  ADDLW  22
171C:  MOVWF  01
171E:  MOVLW  00
1720:  ADDWFC 03,F
1722:  MOVFF  01,11C
1726:  MOVFF  03,11D
172A:  MOVF   x0F,W
172C:  MULLW  3D
172E:  MOVF   FF3,W
1730:  CLRF   x1F
1732:  MOVWF  x1E
1734:  MOVLW  33
1736:  ADDWF  x1E,W
1738:  MOVWF  01
173A:  MOVLW  00
173C:  ADDWFC x1F,W
173E:  MOVWF  03
1740:  MOVF   01,W
1742:  ADDLW  22
1744:  MOVWF  FE9
1746:  MOVLW  00
1748:  ADDWFC 03,W
174A:  MOVWF  FEA
174C:  MOVFF  FEF,120
1750:  MOVFF  FEC,121
1754:  MOVFF  FEC,122
1758:  MOVFF  FEC,123
175C:  MOVFF  06,00
1760:  MOVFF  07,01
1764:  CLRF   02
1766:  CLRF   03
1768:  MOVF   x20,W
176A:  ADDWF  00,F
176C:  MOVF   x21,W
176E:  ADDWFC 01,F
1770:  MOVF   x22,W
1772:  ADDWFC 02,F
1774:  MOVF   x23,W
1776:  ADDWFC 03,F
1778:  MOVFF  11D,FEA
177C:  MOVFF  11C,FE9
1780:  MOVFF  00,FEF
1784:  MOVFF  01,FEC
1788:  MOVFF  02,FEC
178C:  MOVFF  03,FEC
.................... 		//that file_addr_ptr points to 
.................... 	} 
.................... 	address=file[fnbr].addr_ptr+file[fnbr].offset-file[fnbr].cluster_offset; 
1790:  MOVF   x0F,W
1792:  MULLW  3D
1794:  MOVF   FF3,W
1796:  CLRF   x1B
1798:  MOVWF  x1A
179A:  MOVLW  2B
179C:  ADDWF  x1A,W
179E:  MOVWF  01
17A0:  MOVLW  00
17A2:  ADDWFC x1B,W
17A4:  MOVWF  03
17A6:  MOVF   01,W
17A8:  ADDLW  22
17AA:  MOVWF  FE9
17AC:  MOVLW  00
17AE:  ADDWFC 03,W
17B0:  MOVWF  FEA
17B2:  MOVFF  FEF,11C
17B6:  MOVFF  FEC,11D
17BA:  MOVFF  FEC,11E
17BE:  MOVFF  FEC,11F
17C2:  MOVF   x0F,W
17C4:  MULLW  3D
17C6:  MOVF   FF3,W
17C8:  CLRF   x21
17CA:  MOVWF  x20
17CC:  MOVLW  37
17CE:  ADDWF  x20,W
17D0:  MOVWF  01
17D2:  MOVLW  00
17D4:  ADDWFC x21,W
17D6:  MOVWF  03
17D8:  MOVF   01,W
17DA:  ADDLW  22
17DC:  MOVWF  FE9
17DE:  MOVLW  00
17E0:  ADDWFC 03,W
17E2:  MOVWF  FEA
17E4:  MOVFF  FEF,00
17E8:  MOVFF  FEC,01
17EC:  MOVFF  FEC,02
17F0:  MOVFF  FEC,03
17F4:  MOVF   00,W
17F6:  ADDWF  x1C,W
17F8:  MOVWF  x22
17FA:  MOVF   01,W
17FC:  ADDWFC x1D,W
17FE:  MOVWF  x23
1800:  MOVF   02,W
1802:  ADDWFC x1E,W
1804:  MOVWF  x24
1806:  MOVF   03,W
1808:  ADDWFC x1F,W
180A:  MOVWF  x25
180C:  MOVF   x0F,W
180E:  MULLW  3D
1810:  MOVF   FF3,W
1812:  CLRF   x27
1814:  MOVWF  x26
1816:  MOVLW  33
1818:  ADDWF  x26,W
181A:  MOVWF  01
181C:  MOVLW  00
181E:  ADDWFC x27,W
1820:  MOVWF  03
1822:  MOVF   01,W
1824:  ADDLW  22
1826:  MOVWF  FE9
1828:  MOVLW  00
182A:  ADDWFC 03,W
182C:  MOVWF  FEA
182E:  MOVFF  FEF,00
1832:  MOVFF  FEC,01
1836:  MOVFF  FEC,02
183A:  MOVFF  FEC,03
183E:  MOVF   00,W
1840:  SUBWF  x22,W
1842:  MOVWF  x12
1844:  MOVF   01,W
1846:  SUBWFB x23,W
1848:  MOVWF  x13
184A:  MOVF   02,W
184C:  SUBWFB x24,W
184E:  MOVWF  x14
1850:  MOVF   03,W
1852:  SUBWFB x25,W
1854:  MOVWF  x15
.................... 	#IF MMC_READ_TRACE 
.................... 		//printf("\n\r offset=%lu",cluster_offset); 
.................... 		printf("\n\r data_area_address=%lu",address); 
.................... 		printf("\n\r cluster_size_bytes=%lu",cluster_size_bytes); 
....................  
.................... 		//printf("\n\r file_addr_ptr=%lu",file_addr_ptr); 
.................... 	#ENDIF 
....................  
.................... 	if (read_BLOCK(address,buff)==false)return(12); /// read block into buff 
1856:  MOVFF  115,167
185A:  MOVFF  114,166
185E:  MOVFF  113,165
1862:  MOVFF  112,164
1866:  MOVFF  111,169
186A:  MOVFF  110,168
186E:  MOVLB  0
1870:  CALL   02FC
1874:  MOVF   01,F
1876:  BNZ   1880
1878:  MOVLW  0C
187A:  MOVWF  01
187C:  MOVLB  1
187E:  BRA    1AF6
....................  
.................... 	if ( file[fnbr].offset+file[fnbr].rec_size< file[fnbr].size ) file[fnbr].offset=file[fnbr].offset+file[fnbr].rec_size; 
1880:  MOVLB  1
1882:  MOVF   x0F,W
1884:  MULLW  3D
1886:  MOVF   FF3,W
1888:  CLRF   x1B
188A:  MOVWF  x1A
188C:  MOVLW  37
188E:  ADDWF  x1A,W
1890:  MOVWF  01
1892:  MOVLW  00
1894:  ADDWFC x1B,W
1896:  MOVWF  03
1898:  MOVF   01,W
189A:  ADDLW  22
189C:  MOVWF  FE9
189E:  MOVLW  00
18A0:  ADDWFC 03,W
18A2:  MOVWF  FEA
18A4:  MOVFF  FEF,11C
18A8:  MOVFF  FEC,11D
18AC:  MOVFF  FEC,11E
18B0:  MOVFF  FEC,11F
18B4:  MOVF   x0F,W
18B6:  MULLW  3D
18B8:  MOVF   FF3,W
18BA:  CLRF   x21
18BC:  MOVWF  x20
18BE:  MOVLW  3B
18C0:  ADDWF  x20,W
18C2:  MOVWF  01
18C4:  MOVLW  00
18C6:  ADDWFC x21,W
18C8:  MOVWF  03
18CA:  MOVF   01,W
18CC:  ADDLW  22
18CE:  MOVWF  FE9
18D0:  MOVLW  00
18D2:  ADDWFC 03,W
18D4:  MOVWF  FEA
18D6:  MOVFF  FEC,03
18DA:  MOVF   FED,F
18DC:  MOVF   FEF,W
18DE:  ADDWF  x1C,W
18E0:  MOVWF  x22
18E2:  MOVF   03,W
18E4:  ADDWFC x1D,W
18E6:  MOVWF  x23
18E8:  MOVLW  00
18EA:  ADDWFC x1E,W
18EC:  MOVWF  x24
18EE:  MOVLW  00
18F0:  ADDWFC x1F,W
18F2:  MOVWF  x25
18F4:  MOVF   x0F,W
18F6:  MULLW  3D
18F8:  MOVF   FF3,W
18FA:  CLRF   x27
18FC:  MOVWF  x26
18FE:  MOVLW  2F
1900:  ADDWF  x26,W
1902:  MOVWF  01
1904:  MOVLW  00
1906:  ADDWFC x27,W
1908:  MOVWF  03
190A:  MOVF   01,W
190C:  ADDLW  22
190E:  MOVWF  FE9
1910:  MOVLW  00
1912:  ADDWFC 03,W
1914:  MOVWF  FEA
1916:  MOVFF  FEF,00
191A:  MOVFF  FEC,01
191E:  MOVFF  FEC,02
1922:  MOVFF  FEC,03
1926:  MOVF   x25,W
1928:  SUBWF  03,W
192A:  BNC   19F4
192C:  BNZ   1944
192E:  MOVF   x24,W
1930:  SUBWF  02,W
1932:  BNC   19F4
1934:  BNZ   1944
1936:  MOVF   x23,W
1938:  SUBWF  01,W
193A:  BNC   19F4
193C:  BNZ   1944
193E:  MOVF   00,W
1940:  SUBWF  x22,W
1942:  BC    19F4
1944:  MOVF   x0F,W
1946:  MULLW  3D
1948:  MOVF   FF3,W
194A:  CLRF   x1B
194C:  MOVWF  x1A
194E:  MOVLW  37
1950:  ADDWF  x1A,W
1952:  MOVWF  01
1954:  MOVLW  00
1956:  ADDWFC x1B,W
1958:  MOVWF  03
195A:  MOVF   01,W
195C:  ADDLW  22
195E:  MOVWF  01
1960:  MOVLW  00
1962:  ADDWFC 03,F
1964:  MOVFF  01,11C
1968:  MOVFF  03,11D
196C:  MOVF   x0F,W
196E:  MULLW  3D
1970:  MOVF   FF3,W
1972:  CLRF   x1F
1974:  MOVWF  x1E
1976:  MOVLW  37
1978:  ADDWF  x1E,W
197A:  MOVWF  01
197C:  MOVLW  00
197E:  ADDWFC x1F,W
1980:  MOVWF  03
1982:  MOVF   01,W
1984:  ADDLW  22
1986:  MOVWF  FE9
1988:  MOVLW  00
198A:  ADDWFC 03,W
198C:  MOVWF  FEA
198E:  MOVFF  FEF,120
1992:  MOVFF  FEC,121
1996:  MOVFF  FEC,122
199A:  MOVFF  FEC,123
199E:  MOVF   x0F,W
19A0:  MULLW  3D
19A2:  MOVF   FF3,W
19A4:  CLRF   x25
19A6:  MOVWF  x24
19A8:  MOVLW  3B
19AA:  ADDWF  x24,W
19AC:  MOVWF  01
19AE:  MOVLW  00
19B0:  ADDWFC x25,W
19B2:  MOVWF  03
19B4:  MOVF   01,W
19B6:  ADDLW  22
19B8:  MOVWF  FE9
19BA:  MOVLW  00
19BC:  ADDWFC 03,W
19BE:  MOVWF  FEA
19C0:  MOVFF  FEC,03
19C4:  MOVF   FED,F
19C6:  MOVF   FEF,W
19C8:  ADDWF  x20,W
19CA:  MOVWF  00
19CC:  MOVF   03,W
19CE:  ADDWFC x21,W
19D0:  MOVWF  01
19D2:  MOVLW  00
19D4:  ADDWFC x22,W
19D6:  MOVWF  02
19D8:  MOVLW  00
19DA:  ADDWFC x23,W
19DC:  MOVFF  11D,FEA
19E0:  MOVFF  11C,FE9
19E4:  MOVFF  00,FEF
19E8:  MOVFF  01,FEC
19EC:  MOVFF  02,FEC
19F0:  MOVWF  FEC
.................... 	else{ /// end of file 
19F2:  BRA    1AF2
.................... 		#IF MMC_READ_TRACE 
.................... 			printf("eof size=%lu",file[fnbr].size); 
.................... 		#ENDIF 
.................... 		buff[ file[fnbr].size-file[fnbr].offset]=0; /// short record 
19F4:  MOVF   x0F,W
19F6:  MULLW  3D
19F8:  MOVF   FF3,W
19FA:  CLRF   x1B
19FC:  MOVWF  x1A
19FE:  MOVLW  2F
1A00:  ADDWF  x1A,W
1A02:  MOVWF  01
1A04:  MOVLW  00
1A06:  ADDWFC x1B,W
1A08:  MOVWF  03
1A0A:  MOVF   01,W
1A0C:  ADDLW  22
1A0E:  MOVWF  FE9
1A10:  MOVLW  00
1A12:  ADDWFC 03,W
1A14:  MOVWF  FEA
1A16:  MOVFF  FEF,11C
1A1A:  MOVFF  FEC,11D
1A1E:  MOVFF  FEC,11E
1A22:  MOVFF  FEC,11F
1A26:  MOVF   x0F,W
1A28:  MULLW  3D
1A2A:  MOVF   FF3,W
1A2C:  CLRF   x21
1A2E:  MOVWF  x20
1A30:  MOVLW  37
1A32:  ADDWF  x20,W
1A34:  MOVWF  01
1A36:  MOVLW  00
1A38:  ADDWFC x21,W
1A3A:  MOVWF  03
1A3C:  MOVF   01,W
1A3E:  ADDLW  22
1A40:  MOVWF  FE9
1A42:  MOVLW  00
1A44:  ADDWFC 03,W
1A46:  MOVWF  FEA
1A48:  MOVFF  FEF,00
1A4C:  MOVFF  FEC,01
1A50:  MOVFF  FEC,02
1A54:  MOVFF  FEC,03
1A58:  MOVF   00,W
1A5A:  SUBWF  x1C,W
1A5C:  MOVWF  x22
1A5E:  MOVF   01,W
1A60:  SUBWFB x1D,W
1A62:  MOVWF  x23
1A64:  MOVF   02,W
1A66:  SUBWFB x1E,W
1A68:  MOVF   03,W
1A6A:  SUBWFB x1F,W
1A6C:  MOVF   x10,W
1A6E:  ADDWF  x22,W
1A70:  MOVWF  FE9
1A72:  MOVF   x11,W
1A74:  ADDWFC x23,W
1A76:  MOVWF  FEA
1A78:  CLRF   FEF
.................... 		file[fnbr].offset=file[fnbr].size; 
1A7A:  MOVF   x0F,W
1A7C:  MULLW  3D
1A7E:  MOVF   FF3,W
1A80:  CLRF   x1B
1A82:  MOVWF  x1A
1A84:  MOVLW  37
1A86:  ADDWF  x1A,W
1A88:  MOVWF  01
1A8A:  MOVLW  00
1A8C:  ADDWFC x1B,W
1A8E:  MOVWF  03
1A90:  MOVF   01,W
1A92:  ADDLW  22
1A94:  MOVWF  01
1A96:  MOVLW  00
1A98:  ADDWFC 03,F
1A9A:  MOVFF  01,11C
1A9E:  MOVFF  03,11D
1AA2:  MOVF   x0F,W
1AA4:  MULLW  3D
1AA6:  MOVF   FF3,W
1AA8:  CLRF   x1F
1AAA:  MOVWF  x1E
1AAC:  MOVLW  2F
1AAE:  ADDWF  x1E,W
1AB0:  MOVWF  01
1AB2:  MOVLW  00
1AB4:  ADDWFC x1F,W
1AB6:  MOVWF  03
1AB8:  MOVF   01,W
1ABA:  ADDLW  22
1ABC:  MOVWF  FE9
1ABE:  MOVLW  00
1AC0:  ADDWFC 03,W
1AC2:  MOVWF  FEA
1AC4:  MOVFF  FEF,00
1AC8:  MOVFF  FEC,01
1ACC:  MOVFF  FEC,02
1AD0:  MOVFF  FEC,03
1AD4:  MOVFF  11D,FEA
1AD8:  MOVFF  11C,FE9
1ADC:  MOVFF  00,FEF
1AE0:  MOVFF  01,FEC
1AE4:  MOVFF  02,FEC
1AE8:  MOVFF  03,FEC
.................... 		return(255); //eof 
1AEC:  MOVLW  FF
1AEE:  MOVWF  01
1AF0:  BRA    1AF6
.................... 	} 
.................... 	return(0); 
1AF2:  MOVLW  00
1AF4:  MOVWF  01
.................... } 
1AF6:  MOVLB  0
1AF8:  GOTO   1E92 (RETURN)
....................  
....................  
.................... ////////////////////////////////////////////////////////////////////////////////// 
.................... ////////////////////////////// WRITE FILE ///////////////////////////////////// 
.................... ////////////////////////////////////////////////////////////////////////////////// 
.................... #separate 
.................... int file_write(int8 fnbr,int *buff){ 
.................... 	//// buff size must be at least the recordsize requested in File open 
.................... 	//// the record is updated only chars beyond rec_size are ignored 
.................... 	/// set up for write 
.................... 	/// A MMC write is restricted it must be for a block and allign on block boundaries 
.................... 	/// blocklen must be exactly 512 and start address must be the begining of a 
.................... 	/// sector 
.................... 	/// the buff could potentially span a sector and or span a block(512) boundary 
.................... 	/// ex there could be 1byte left in a block and 1 byte lect in a sector 
.................... 	// if the block is the last block in the sector 
.................... 	/// worst case we could write to two blocks and need a new sector 
.................... 	int32 address,nxt_cluster; 
....................  
.................... 	int16 in_cluster_size,out_cluster_size; 
.................... 	int8 appending_flag; 
.................... 	appending_flag=0; 
.................... 	if (file[fnbr].offset + file[fnbr].rec_size>=file[fnbr].size) appending_flag=1; 
....................  
....................  
.................... 	/// find the cluster containing the offset 
.................... 	if ( file[fnbr].offset+file[fnbr].rec_size>=file[fnbr].cluster_offset + cluster_size_bytes){ 
.................... 		#IF MMC_WRITE_TRACE 
.................... 			printf("spanning cluster \n\r"); 
.................... 		#ENDIF 
.................... 		/// spans the current cluster so we split the write 
.................... 		in_cluster_size=file[fnbr].cluster_offset+cluster_size_bytes-file[fnbr].offset; 
.................... 		/// bytes from start of file to end of this cluste- bytes into the file 
.................... 		out_cluster_size=file[fnbr].rec_size - in_cluster_size; 
.................... 		#IF MMC_WRITE_TRACE 
.................... 			printf("write>> spanning cluster inside=%lu outside=%lu \n\r",in_cluster_size,out_cluster_size); 
.................... 		#ENDIF 
.................... 		address=file[fnbr].addr_ptr+file[fnbr].offset - file[fnbr].cluster_offset; 
.................... 		// physical address= 
.................... 		// physical address of the cluster +offset from begining of file 
.................... 		// - offset from the begining of file for the byte at the begining of the cluster 
.................... 		#IF MMC_WRITE_TRACE 
.................... 			printf("write file>>cluster=%lu in clstr addr=%lu",file[fnbr].this_cluster_ptr,address); 
.................... 		#ENDIF 
.................... 		//// address=physical offset of this cluster +bytes into this cluster 
.................... 		if(write_BLOCK(address,buff,in_cluster_size)==false)return(81); //// write first chunk 
....................  
....................  
....................  
.................... 		/// allocate the next cluster 
.................... 		nxt_cluster=cluster_addr(fnbr,NEXT_CLUSTER); ///physical address of file data that the 
.................... 		/// specific cluster indexes 
.................... 		#IF MMC_WRITE_TRACE 
.................... 			printf("nxt_cluster=%lu",nxt_cluster); 
.................... 		#ENDIF 
....................  
.................... 		if ( nxt_cluster==0xFFFFFFFF){ 
.................... 			#IF MMC_WRITE_TRACE 
.................... 				printf("updating FAT"); 
.................... 			#ENDIF 
.................... 			//// FAT2 is an identical copy of FAT1 
.................... 			file_new_cluster(fnbr,1); /// a new cluster is allocated in FAT1 
.................... 			file_new_cluster(fnbr,2); /// a new cluster is allocated in FAT2 
.................... 			nxt_cluster=cluster_addr(fnbr,NEXT_CLUSTER); ///physical address of file data that the 
.................... 			#IF MMC_WRITE_TRACE 
.................... 				printf("\n\r write>>nxt_cluster addr=%lu this clstr=%lu next=%lu",nxt_cluster,file[fnbr].this_cluster_ptr,file[fnbr].next_cluster_ptr); /// specific cluster indexes 
.................... 			#ENDIF 
.................... 		} 
....................  
.................... 		file[fnbr].addr_ptr =nxt_cluster; 
.................... 		file[fnbr].cluster_offset=file[fnbr].cluster_offset + cluster_size_bytes; //foffset is the byte offset within the file 
.................... 		//that file_addr_ptr points to 
.................... 		address=file[fnbr].addr_ptr + file[fnbr].offset - file[fnbr].cluster_offset + in_cluster_size; 
.................... 		#IF MMC_WRITE_TRACE 
.................... 			printf("out addr=%lu,out size=%lu",address,out_cluster_size); 
.................... 		#ENDIF 
.................... 		if(write_BLOCK(address,&buff[in_cluster_size],out_cluster_size)==false)return(82); /// write block pads with 0x00 to end of sector 
.................... 	}// end of spanned cluster 
.................... 	else{ 
.................... 		/// within the current cluster 
.................... 		address=file[fnbr].addr_ptr+file[fnbr].offset - file[fnbr].cluster_offset; 
....................  
....................  
....................  
.................... 		if(write_BLOCK(address,buff,file[fnbr].rec_size)==false)return(84); /// write block pads with 0x00 to end of sector 
....................  
.................... 	} 
.................... 	if(appending_flag==1) { 
.................... 		/// if appended we need to up date the file size 
.................... 		file[fnbr].size=file[fnbr].size + file[fnbr].rec_size; /// add one record 
.................... 		address=file[fnbr].dir_addr_ptr+28; /// file size is offset 28 in tiles 
.................... 		#IF MMC_WRITE_TRACE 
.................... 			printf("new file size=%lu",file[fnbr].size); 
.................... 		#ENDIF 
.................... 		buff[0]=make8(file[fnbr].size,0); 
.................... 		buff[1]=make8(file[fnbr].size,1); 
.................... 		buff[2]=make8(file[fnbr].size,2); 
.................... 		buff[3]=make8(file[fnbr].size,3); 
.................... 		MMC_dir_protected=false; 
.................... 		if(write_BLOCK(address,buff,4)==false)return(85); 
.................... 	} 
.................... 	if(set_BLOCKLEN(file[fnbr].rec_size)==false) return(86); /// reset to original rec_size 
.................... 	return(0); 
.................... } 
....................  
....................  
.................... #separate 
.................... int file_set(int fnbr,int32 offset){ 
.................... 	/// file open sets the offset to the begining offset=0 
.................... 	/// this sets the offset within the file ...offset of 0 is a reset 
....................  
.................... 	if(offset>=file[fnbr].size) return(71); 
....................  
.................... 	file[fnbr].offset=offset; //// overwrite the existing offset 
.................... 	file[fnbr].next_cluster_ptr=file[fnbr].root_cluster_ptr; /// set current ptr to beginning 
.................... 	file[fnbr].cluster_offset=0; 
.................... 	// move the cluster to the one containing the offset 
....................  
.................... 	while ( offset>cluster_size_bytes ){ 
....................  
.................... 		file[fnbr].addr_ptr=cluster_addr(fnbr,NEXT_CLUSTER); 
.................... 		file[fnbr].cluster_offset+=cluster_size_bytes; //foffset is the byte offset within the file 
.................... 		if (offset-cluster_size_bytes >0) offset= offset - cluster_size_bytes; 
....................  
.................... 	} 
.................... 	return(0); 
.................... } 
....................  
....................  
.................... #separate 
.................... int file_new_cluster(int8 fnbr,int8 mode){ ///////////// this does identical writes to either the FAT1 and FAT2 sectors 
.................... 	int16 eof_cluster; 
....................  
.................... 	char buff[2],tmp_buff[2]; 
.................... 	int32 address; 
.................... 	int32 fat_address; 
.................... 	int16 slot; 
.................... 	/// an unused cluster has the value 0x0000 as its next cluster ptr 
.................... 	/// a used cluster has either 0xFFFF meaning last in chain 
.................... 	/// or a valid cluster displacement in the FAT1 amd FAT2 area 
.................... 	/// to append a cluster the 0XFFFF needs to be replaced by the appended 
.................... 	/// cluster location and the appended locations data (next ptr) needs to be set to 0XFFFF 
....................  
....................  
....................  
.................... 	eof_cluster=file[fnbr].this_cluster_ptr; 
.................... 	#IF MMC_NEW_CLUSTER 
.................... 		printf("the cluster with eof (FFFF)=%lu \n\r",eof_cluster); 
.................... 	#ENDIF 
....................  
.................... 	slot=0; 
.................... 	if(set_BLOCKLEN((int32)2)==false)return(false); // force blocklen to 2 
.................... 	/// use global address of FAT1 assigned by INIT 
.................... 	if (mode==2)fat_address=fat2_address; 
.................... 	else fat_address=fat1_address; 
.................... 	address=fat_address; 
....................  
.................... 	#IF MMC_NEW_CLUSTER 
.................... 		printf("mode=%u FAT addr=%lu \n\r",mode,address); 
.................... 	#ENDIF 
....................  
.................... 	do{ 
.................... 		if(read_block(address,buff)==false) return(false) ; 
.................... 		slot=slot+1; 
.................... 		address=address+2; 
.................... 		//printf(" slot %lu =%2x %2x",slot,buff[0],buff[1]); 
.................... 	} 
.................... 	while (buff[0]!=0 || buff[1]!=0); 
....................  
.................... 	address=address-2; // correct for over step 
.................... 	slot=slot-1; 
....................  
....................  
.................... 	#IF MMC_NEW_CLUSTER 
.................... 		printf("slot=%lu address=%lu",slot,address); 
.................... 	#ENDIF 
....................  
.................... 	/// found an unused cluster 
.................... 	tmp_buff[0]=0xFF;tmp_buff[1]=0xFF; /// stamp it as last 
.................... 	MMC_dir_protected=false; /// allow writes to the protected areas 
.................... 	if(write_block(address,tmp_buff,2)==false ) return(false); 
....................  
.................... 	///////////////////////////////////////////// 
.................... 	/// update prev cluster with 0xFFFF in it 
.................... 	tmp_buff[1]=make8(slot,1); 
.................... 	tmp_buff[0]=make8(slot,0); 
.................... 	if (mode==1){ 
.................... 		//// update the file info 
.................... 		file[fnbr].next_cluster_ptr=slot; 
.................... 		#IF MMC_NEW_CLUSTER 
.................... 			printf("cluster %lu was updated to point to %lu",file[fnbr].this_cluster_ptr,file[fnbr].next_cluster_ptr); 
.................... 		#ENDIF 
.................... 	} 
.................... 	/// compute physical address of the current cluster 
.................... 	MMC_dir_protected=false; /// allow writes to the protected areas 
.................... 	if(write_BLOCK(fat_address+(file[fnbr].this_cluster_ptr)*2,tmp_buff,2)==false) return(33); 
.................... 	if(set_BLOCKLEN((int32)file[fnbr].rec_size)==false)return(false); // reset blocklen 
....................  
.................... 	return(true); 
.................... } 
....................  
....................  
.................... signed int strncmp(char *s1, char *s2, int n){ 
.................... 	for (; n > 0; s1++, s2++, n--){ 
*
0CEA:  MOVLB  1
0CEC:  MOVF   x54,F
0CEE:  BZ    0D7E
.................... 		if (*s1 != *s2) return((*s1 <*s2) ? -1: 1); 
0CF0:  MOVFF  151,03
0CF4:  MOVFF  150,FE9
0CF8:  MOVFF  151,FEA
0CFC:  MOVFF  FEF,155
0D00:  MOVFF  153,03
0D04:  MOVFF  152,FE9
0D08:  MOVFF  153,FEA
0D0C:  MOVF   FEF,W
0D0E:  SUBWF  x55,W
0D10:  BZ    0D48
0D12:  MOVFF  151,03
0D16:  MOVFF  150,FE9
0D1A:  MOVFF  151,FEA
0D1E:  MOVFF  FEF,155
0D22:  MOVFF  153,03
0D26:  MOVFF  152,FE9
0D2A:  MOVFF  153,FEA
0D2E:  MOVF   FEF,W
0D30:  SUBWF  x55,W
0D32:  BC    0D40
0D34:  MOVLW  FF
0D36:  MOVWF  00
0D38:  MOVWF  01
0D3A:  MOVWF  02
0D3C:  MOVWF  03
0D3E:  BRA    0D42
0D40:  MOVLW  01
0D42:  MOVWF  01
0D44:  BRA    0D82
.................... 		else if (*s1 == '\0') return(0); 
0D46:  BRA    0D5E
0D48:  MOVFF  151,03
0D4C:  MOVFF  150,FE9
0D50:  MOVFF  151,FEA
0D54:  MOVF   FEF,F
0D56:  BNZ   0D5E
0D58:  MOVLW  00
0D5A:  MOVWF  01
0D5C:  BRA    0D82
.................... 	} 
0D5E:  MOVFF  151,03
0D62:  MOVF   x50,W
0D64:  INCF   x50,F
0D66:  BTFSC  FD8.2
0D68:  INCF   x51,F
0D6A:  MOVFF  153,03
0D6E:  MOVF   x52,W
0D70:  INCF   x52,F
0D72:  BTFSC  FD8.2
0D74:  INCF   x53,F
0D76:  DECF   x54,F
0D78:  MOVLB  0
0D7A:  BRA    0CEA
0D7C:  MOVLB  1
.................... 	return(0); 
0D7E:  MOVLW  00
0D80:  MOVWF  01
.................... } 
0D82:  MOVLB  0
0D84:  GOTO   10E0 (RETURN)
....................  
....................  
.................... void main(){ 
*
1C40:  CLRF   FF8
1C42:  BCF    FD0.7
1C44:  CLRF   FEA
1C46:  CLRF   FE9
1C48:  MOVLW  2A
1C4A:  MOVWF  FAF
1C4C:  MOVLW  26
1C4E:  MOVWF  FAC
1C50:  MOVLW  90
1C52:  MOVWF  FAB
1C54:  BSF    FC1.0
1C56:  BSF    FC1.1
1C58:  BSF    FC1.2
1C5A:  BCF    FC1.3
1C5C:  CLRF   05
1C5E:  CLRF   20
1C60:  MOVLW  01
1C62:  MOVWF  21
....................  
.................... int r1,i,j,error,error0,error1; 
.................... int16 rec_no; 
.................... int16 index,rec_size; 
.................... int32 offset; 
.................... char fname[32],buff0[MMC_BUFF_SIZE+1],buff1[MMC_BUFF_SIZE+1]; 
.................... char c; 
....................  
....................  
....................  
.................... setup_adc_ports(NO_ANALOGS); 
1C64:  BSF    FC1.0
1C66:  BSF    FC1.1
1C68:  BSF    FC1.2
1C6A:  BCF    FC1.3
....................  
....................  
.................... set_tris_c(0b10010011); //c7=rx I, c6=tx O, c5 SDO O,c4 SDI I 
1C6C:  MOVLW  93
1C6E:  MOVWF  F94
....................  
.................... output_high(_CS); 
1C70:  BCF    F94.2
1C72:  BSF    F8B.2
....................  
....................  
.................... printf("\r\n**** SD / MMC FAT16  Read Demo for Sonsivri **** "); 
1C74:  MOVLB  1
1C76:  CLRF   x0F
1C78:  MOVF   x0F,W
1C7A:  MOVLB  0
1C7C:  CALL   0048
1C80:  IORLW  00
1C82:  BZ    1C92
1C84:  MOVLB  1
1C86:  INCF   x0F,F
1C88:  BTFSS  F9E.4
1C8A:  BRA    1C88
1C8C:  MOVWF  FAD
1C8E:  BRA    1C78
1C90:  MOVLB  0
.................... printf("\r\n"); 
1C92:  MOVLB  1
1C94:  CLRF   x0F
1C96:  MOVF   x0F,W
1C98:  MOVLB  0
1C9A:  CALL   008C
1C9E:  IORLW  00
1CA0:  BZ    1CB0
1CA2:  MOVLB  1
1CA4:  INCF   x0F,F
1CA6:  BTFSS  F9E.4
1CA8:  BRA    1CA6
1CAA:  MOVWF  FAD
1CAC:  BRA    1C96
1CAE:  MOVLB  0
.................... Delay_ms(1000); 
1CB0:  MOVLW  04
1CB2:  MOVLB  1
1CB4:  MOVWF  x0F
1CB6:  MOVLW  FA
1CB8:  MOVWF  x48
1CBA:  MOVLB  0
1CBC:  CALL   01E0
1CC0:  MOVLB  1
1CC2:  DECFSZ x0F,F
1CC4:  BRA    1CB6
.................... printf("\r\Now Open COUNTRY.TXT File on SD Card  "); 
1CC6:  CLRF   x0F
1CC8:  MOVF   x0F,W
1CCA:  MOVLB  0
1CCC:  CALL   00A0
1CD0:  IORLW  00
1CD2:  BZ    1CE2
1CD4:  MOVLB  1
1CD6:  INCF   x0F,F
1CD8:  BTFSS  F9E.4
1CDA:  BRA    1CD8
1CDC:  MOVWF  FAD
1CDE:  BRA    1CC8
1CE0:  MOVLB  0
.................... printf("\r\n"); 
1CE2:  MOVLB  1
1CE4:  CLRF   x0F
1CE6:  MOVF   x0F,W
1CE8:  MOVLB  0
1CEA:  CALL   008C
1CEE:  IORLW  00
1CF0:  BZ    1D00
1CF2:  MOVLB  1
1CF4:  INCF   x0F,F
1CF6:  BTFSS  F9E.4
1CF8:  BRA    1CF6
1CFA:  MOVWF  FAD
1CFC:  BRA    1CE6
1CFE:  MOVLB  0
.................... Delay_ms(3000); 
1D00:  MOVLW  0C
1D02:  MOVLB  1
1D04:  MOVWF  x0F
1D06:  MOVLW  FA
1D08:  MOVWF  x48
1D0A:  MOVLB  0
1D0C:  CALL   01E0
1D10:  MOVLB  1
1D12:  DECFSZ x0F,F
1D14:  BRA    1D06
....................  
....................  
.................... SETUP_SPI (SPI_MASTER |  SPI_SS_DISABLED |SPI_H_TO_L| SPI_CLK_DIV_16 | SPI_XMIT_L_TO_H); 
1D16:  BCF    FC6.5
1D18:  BCF    F94.5
1D1A:  BSF    F94.4
1D1C:  BCF    F94.3
1D1E:  MOVLW  31
1D20:  MOVWF  FC6
1D22:  MOVLW  00
1D24:  MOVWF  FC7
....................  
....................  
.................... buff0[MMC_BUFF_SIZE]=0; 
1D26:  MOVLB  0
1D28:  CLRF   xEC
.................... buff1[MMC_BUFF_SIZE]=0; 
1D2A:  MOVLB  1
1D2C:  CLRF   x0D
.................... rec_no=0; 
1D2E:  MOVLB  0
1D30:  CLRF   xA3
1D32:  CLRF   xA2
....................  
.................... ///////// init MMC //////////////////////////////////////// 
.................... error=init_MMC(10); 
1D34:  MOVLW  0A
1D36:  MOVLB  1
1D38:  MOVWF  x0F
1D3A:  MOVLB  0
1D3C:  GOTO   048C
1D40:  MOVFF  01,9F
.................... if (error>0) { 
1D44:  MOVF   x9F,F
1D46:  BZ    1D4A
.................... goto mmc_exit; 
1D48:  BRA    1F06
.................... } 
....................  
....................  
.................... printf("\n\r MMC initialized \n\r"); 
1D4A:  MOVLB  1
1D4C:  CLRF   x0F
1D4E:  MOVF   x0F,W
1D50:  MOVLB  0
1D52:  CALL   00D8
1D56:  IORLW  00
1D58:  BZ    1D68
1D5A:  MOVLB  1
1D5C:  INCF   x0F,F
1D5E:  BTFSS  F9E.4
1D60:  BRA    1D5E
1D62:  MOVWF  FAD
1D64:  BRA    1D4E
1D66:  MOVLB  0
.................... rec_size=MMC_BUFF_SIZE; 
1D68:  CLRF   xA7
1D6A:  MOVLW  20
1D6C:  MOVWF  xA6
....................  
....................  
.................... //strcpy(fname,"HOME\\HOME.TXT"); 
.................... strcpy(fname,"COUNTRY.TXT"); 
1D6E:  CLRF   FEA
1D70:  MOVLW  AC
1D72:  MOVWF  FE9
1D74:  MOVFF  FF2,10F
1D78:  BCF    FF2.7
1D7A:  MOVLW  00
1D7C:  CALL   00FE
1D80:  TBLRD*-
1D82:  TBLRD*+
1D84:  MOVF   FF5,W
1D86:  MOVWF  FEE
1D88:  IORLW  00
1D8A:  BNZ   1D82
1D8C:  MOVLB  1
1D8E:  BTFSC  x0F.7
1D90:  BSF    FF2.7
.................... rec_size=MMC_BUFF_SIZE; 
1D92:  MOVLB  0
1D94:  CLRF   xA7
1D96:  MOVLW  20
1D98:  MOVWF  xA6
.................... error0=open_file(0,fname,rec_size); 
1D9A:  MOVLB  1
1D9C:  CLRF   x0F
1D9E:  CLRF   x11
1DA0:  MOVLW  AC
1DA2:  MOVWF  x10
1DA4:  MOVFF  A7,113
1DA8:  MOVFF  A6,112
1DAC:  MOVLB  0
1DAE:  GOTO   0D88
1DB2:  MOVFF  01,A0
....................  
.................... if (error0>0) { 
1DB6:  MOVF   xA0,F
1DB8:  BZ    1DFC
.................... printf("\n\r fopen as 0 failed error=%U\n\r",error); 
1DBA:  MOVLB  1
1DBC:  CLRF   x0F
1DBE:  MOVF   x0F,W
1DC0:  MOVLB  0
1DC2:  CALL   011A
1DC6:  MOVLB  1
1DC8:  INCF   x0F,F
1DCA:  MOVWF  00
1DCC:  MOVF   00,W
1DCE:  BTFSS  F9E.4
1DD0:  BRA    1DCE
1DD2:  MOVWF  FAD
1DD4:  MOVLW  1B
1DD6:  SUBWF  x0F,W
1DD8:  BNZ   1DBE
1DDA:  MOVFF  9F,110
1DDE:  MOVLW  1B
1DE0:  MOVWF  x11
1DE2:  MOVLB  0
1DE4:  CALL   13F0
1DE8:  MOVLW  0A
1DEA:  BTFSS  F9E.4
1DEC:  BRA    1DEA
1DEE:  MOVWF  FAD
1DF0:  MOVLW  0D
1DF2:  BTFSS  F9E.4
1DF4:  BRA    1DF2
1DF6:  MOVWF  FAD
.................... goto mmc_exit; 
1DF8:  BRA    1F06
.................... } 
.................... else printf("\n\r opened as 0 file %s with rec size %lu \n\r",fname,rec_size); 
1DFA:  BRA    1E82
1DFC:  MOVLB  1
1DFE:  CLRF   x0F
1E00:  MOVF   x0F,W
1E02:  MOVLB  0
1E04:  CALL   014A
1E08:  MOVLB  1
1E0A:  INCF   x0F,F
1E0C:  MOVWF  00
1E0E:  MOVF   00,W
1E10:  BTFSS  F9E.4
1E12:  BRA    1E10
1E14:  MOVWF  FAD
1E16:  MOVLW  14
1E18:  SUBWF  x0F,W
1E1A:  BNZ   1E00
1E1C:  CLRF   FEA
1E1E:  MOVLW  AC
1E20:  MOVWF  FE9
1E22:  MOVLW  00
1E24:  IORWF  FEF,W
1E26:  BZ    1E38
1E28:  BTFSS  F9E.4
1E2A:  BRA    1E28
1E2C:  MOVFF  FEF,FAD
1E30:  INCF   FE9,F
1E32:  BTFSC  FD8.2
1E34:  INCF   FEA,F
1E36:  BRA    1E22
1E38:  MOVLW  16
1E3A:  MOVWF  x12
1E3C:  MOVF   x12,W
1E3E:  MOVLB  0
1E40:  CALL   014A
1E44:  MOVLB  1
1E46:  INCF   x12,F
1E48:  MOVWF  00
1E4A:  MOVF   00,W
1E4C:  BTFSS  F9E.4
1E4E:  BRA    1E4C
1E50:  MOVWF  FAD
1E52:  MOVLW  25
1E54:  SUBWF  x12,W
1E56:  BNZ   1E3C
1E58:  MOVLW  10
1E5A:  MOVWF  FE9
1E5C:  MOVFF  A7,114
1E60:  MOVFF  A6,113
1E64:  MOVLB  0
1E66:  GOTO   146E
1E6A:  MOVLW  20
1E6C:  BTFSS  F9E.4
1E6E:  BRA    1E6C
1E70:  MOVWF  FAD
1E72:  MOVLW  0A
1E74:  BTFSS  F9E.4
1E76:  BRA    1E74
1E78:  MOVWF  FAD
1E7A:  MOVLW  0D
1E7C:  BTFSS  F9E.4
1E7E:  BRA    1E7C
1E80:  MOVWF  FAD
....................  
....................  
....................  
....................  
....................  
.................... do { 
....................  
.................... error0=file_read(0,buff0); 
1E82:  MOVLB  1
1E84:  CLRF   x0F
1E86:  CLRF   x11
1E88:  MOVLW  CC
1E8A:  MOVWF  x10
1E8C:  MOVLB  0
1E8E:  GOTO   151A
1E92:  MOVFF  01,A0
....................  
.................... if (error0>0 && error0<255 ) { 
1E96:  MOVF   xA0,F
1E98:  BZ    1EE0
1E9A:  INCFSZ xA0,W
1E9C:  BRA    1EA0
1E9E:  BRA    1EE0
.................... printf("\n\r fread 0 failed error=%U\n\r",error0); 
1EA0:  MOVLB  1
1EA2:  CLRF   x0F
1EA4:  MOVF   x0F,W
1EA6:  MOVLB  0
1EA8:  CALL   0186
1EAC:  MOVLB  1
1EAE:  INCF   x0F,F
1EB0:  MOVWF  00
1EB2:  MOVF   00,W
1EB4:  BTFSS  F9E.4
1EB6:  BRA    1EB4
1EB8:  MOVWF  FAD
1EBA:  MOVLW  18
1EBC:  SUBWF  x0F,W
1EBE:  BNZ   1EA4
1EC0:  MOVFF  A0,110
1EC4:  MOVLW  1B
1EC6:  MOVWF  x11
1EC8:  MOVLB  0
1ECA:  CALL   13F0
1ECE:  MOVLW  0A
1ED0:  BTFSS  F9E.4
1ED2:  BRA    1ED0
1ED4:  MOVWF  FAD
1ED6:  MOVLW  0D
1ED8:  BTFSS  F9E.4
1EDA:  BRA    1ED8
1EDC:  MOVWF  FAD
.................... break; 
1EDE:  BRA    1F06
.................... } 
....................  
.................... printf("%s",buff0); 
1EE0:  CLRF   FEA
1EE2:  MOVLW  CC
1EE4:  MOVWF  FE9
1EE6:  MOVLW  00
1EE8:  IORWF  FEF,W
1EEA:  BZ    1EFC
1EEC:  BTFSS  F9E.4
1EEE:  BRA    1EEC
1EF0:  MOVFF  FEF,FAD
1EF4:  INCF   FE9,F
1EF6:  BTFSC  FD8.2
1EF8:  INCF   FEA,F
1EFA:  BRA    1EE6
....................  
....................  
.................... rec_no++; 
1EFC:  INCF   xA2,F
1EFE:  BTFSC  FD8.2
1F00:  INCF   xA3,F
....................  
.................... } while (error0==0); 
1F02:  MOVF   xA0,F
1F04:  BZ    1E82
....................  
....................  
....................  
.................... mmc_exit: 
.................... printf("\n\r done winhex adj= %lu \n\r",winhex_adj); 
1F06:  MOVLB  1
1F08:  CLRF   x0F
1F0A:  MOVF   x0F,W
1F0C:  MOVLB  0
1F0E:  CALL   01B4
1F12:  MOVLB  1
1F14:  INCF   x0F,F
1F16:  MOVWF  00
1F18:  MOVF   00,W
1F1A:  BTFSS  F9E.4
1F1C:  BRA    1F1A
1F1E:  MOVWF  FAD
1F20:  MOVLW  14
1F22:  SUBWF  x0F,W
1F24:  BNZ   1F0A
1F26:  MOVLW  41
1F28:  MOVWF  FE9
1F2A:  MOVFF  1B,113
1F2E:  MOVFF  1A,112
1F32:  MOVFF  19,111
1F36:  MOVFF  18,110
1F3A:  MOVLB  0
1F3C:  BRA    1B7E
1F3E:  MOVLW  20
1F40:  BTFSS  F9E.4
1F42:  BRA    1F40
1F44:  MOVWF  FAD
1F46:  MOVLW  0A
1F48:  BTFSS  F9E.4
1F4A:  BRA    1F48
1F4C:  MOVWF  FAD
1F4E:  MOVLW  0D
1F50:  BTFSS  F9E.4
1F52:  BRA    1F50
1F54:  MOVWF  FAD
....................  
....................  
....................  
.................... while(true); 
1F56:  BRA    1F56
....................  
....................  
.................... } 
1F58:  SLEEP 

Configuration Fuses:
   Word  1: 2600   H4 NOOSCSEN
   Word  2: 0E0A   BROWNOUT WDT128 NOWDT BORV27 PUT
   Word  3: 0100   CCP2C1
   Word  4: 0081   STVREN NODEBUG NOLVP
   Word  5: C00F   NOPROTECT NOCPD NOCPB
   Word  6: E00F   NOWRT NOWRTD NOWRTB NOWRTC
   Word  7: 400F   NOEBTR NOEBTRB
